\input cwebmac
% -*- mode: c++ -*-
\datethis % print date


\N{0}{1}Introduction.
This is PATLIB, PATtern LIBrary.

This library stores a finite language using the packed dynamic trie
and manipulates patterns. It is used to write a pattern generator.

This library is written in ANSI C++ using the standard template library.
Written and tested on Linux with glibc-2.2.2 and gcc-2.96. This library
should work with any compiler supporting the STL and ANSI C++.

\medskip
Written and maintained by David Anto\v s, {\tt xantos (at) fi.muni.cz}
\medskip
Copyright 2001 David Anto\v s
\medskip
You may use and redistribute this software under the terms of General
Public License. As this software is distributed free of charge, there is
no warranty for the program. The entire risk of this program is with
you.

The author does not want to forbid anyone to use this software,
nevertheless the author considers any military usage unmoral and
unethical.
\medskip
The $\\{ptl\_vers}.\|h$ header file defines the version number (change it
whenever
the library changes) and the CVS identification string.

\Y\B\4\X1:\.{ptl\_vers.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_VERS\_H}\6
\8\#\&{define} \.{PTL\_VERS\_H}\6
\&{const} \&{char} ${}{*}\\{patlib\_version}\K\.{"1.0"};{}$\6
\&{const} \&{char} ${}{*}\\{patlib\_cvs\_id}\K\.{"\$Id:\ patlib.w,v\ 1.1}\)%
\.{27\ 2001/12/04\ 08:10:}\)\.{22\ antos\ Exp\ \$"};{}$\6
\8\#\&{endif}\par
\fi

\M{2}Organization of the code. The code is highly templatized, in fact there
is nothing without templates. Therefore the library is divided into header
files which contain all the code.

The header file names look like {\tt ptl\_<name>.h} where {\tt <name>} is a
shorthand of the full section name. The header files correspond usually to
the ``starred'' sections in the CWEB source. The header files define a
pre-processor variable {\tt PTL\_<name>\_H} which is tested so as not to
load the same header file more then once.

The library has two more or less independent parts. The first part, the
finite language store, may be used separately. It provides methods to
store a finite language in the packed version of trie memory. This may be
also used to store pattern set in the application using patterns.

The second part, the generator, takes input data with marked points of
interest and creates a set of patterns which recognize the points of
interest there. The generator uses the finite language store to keep the
pattern candidates and the patterns.

\fi

\M{3}Dealing with bugs in the library. The software is far from being perfect,
so my English is. Note that a library like this is quite a
specialized tool. The number of users is small, so if you find a bug,
please report it to {\tt xantos (at) fi.muni.cz}. Keep in mind that if
{\it you\/} don't tell me, maybe nobody will.

Please tell me exactly your platform, compiler, the problem you've fallen
into. Please always attach the revision control id you can see above.

So we consider any behaviour different that the documentation says to be a
bug. Feel free to send me any notes and remarks, they will be taken
seriously. Ask anything you want to.

And something more! This code is complicated, nevertheless the commentary
should be clear as much as possible. If the commentary does not match
the program, it is a bug. It is a big bug. So please report it.

If the comments are not clear, if they are messy, it is my fault, not
yours. Do not sit, do not be depressed, complain! (But please do not
mail me before you read it three times :-).)

\Y\B\F\\{iterator} \5
\\{int}\par
\B\F\\{const\_iterator} \5
\\{int}\par
\fi

\N{0}{4}Exception handling in the library.
When anything unpleasant happens the library throws the \\{Patlib\_error}
exception. The exception class is an offspring of \&{string} and it has
\\{what}(\&{void}) function defined. The \\{what} function prints the text the
exception has been constructed with to the standard error output.
The header also includes the \&{exception} although it doesn't use it.

\Y\B\4\X4:\.{ptl\_exc.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_EXC\_H}\6
\8\#\&{define} \.{PTL\_EXC\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<string>}\6
\8\#\&{include} \.{<exception>}\6
\&{class} \&{Patlib\_error} : \&{public} \&{std}\DC\&{string} ${}\{{}$\1\6
\4\&{public}:\5
\&{Patlib\_error}(\&{string} \|s)\1\1\2\2\6
: \&{std}\DC\&{string}(\|s) ${}\{{}$\SHC{ the constructor }\6
\,${}\}{}$\7
\&{void} \\{what}(\&{void})\1\1\2\2\6
${}\{{}$\SHC{ output of the exception text }\1\6
${}\\{cout}\LL{*}\this;{}$\6
\4${}\}{}$\2\2\6
${}\};{}$\6
\8\#\&{endif}\par
\fi

\N{0}{5}Finite language store.
The first thing we need to do is to prepare the way to store a finite
language. For the purpose of pattern generating the trie data structure
seems to be a good choice as it behaves well on not very long words.

\fi

\M{6}We start with the Growing array object. This serves as a potentially
infinite array, simply said it allocates more memory when touching a
previously unaccessed field. It makes implementing the pattern manipulator
easier as we don't have to take care of memory overflow.

\fi

\M{7}The interesting things come next. The Trie pattern manipulator is a finite
language store where each word may have an output information attached to
its end. The simplest case, storing a dictionary, means that the output
information is a boolean value, \\{true} as end of the word. The main
public-accessible methods include inserting a pattern (a word, if you want
to), ``walk through''---it means getting the language word by word, getting
outputs of words, and some optimizing the structure after delete
operations.

Sometimes the one ``output field'' for a word may suit us, sometimes we
need pairs of values. Therefore we provide the Candidate count trie. The
name goes from the main usage of that structure in our generator, we need
to store pairs of numbers when preparing candidate patterns. Nevertheless
the structure may be used with any types it can be compiled with,
practically with numerical ones. The methods here makes only access to
the pairs of values easier.

\fi

\M{8}The ``heavy weights'' follow. The word may also have multiple outputs,
e.g., on different positions. We provide the output store. We suppose the
number of different outputs will be relatively small, therefore the
manipulator with multi-output words consists of two parts, the word
manipulator and the output manipulator, the outputs of a word become
iterators to the output manipulator. The Multi output pattern manipulator
service is an envelope hiding the inner parts. It makes the interface to
word manipulations known from the word manipulator itself and adds several
ways of deleting patterns depending on their outputs.

The offspring, competitive variant of the manipulator, supposes moreover
the output alphabet to be sorted. It provides methods to compute the
competitive variant of the pattern output, it means that the higher values
win over the smaller ones.

\fi

\M{9}And for completeness, we have to drop a word on the simple translate
service.  When testing applications where the word alphabet is simple we
often need the alphabet to be ``translated'' into $\{1,\dots,n\}$ numeric
set. The service does it simply and slowly.

\fi

\N{1}{10}Growing array. Growing array is a service for trie pattern
manipulator.

\Y\B\4\X10:\.{ptl\_ga.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_GA\_H}\C{ To include the header only once }\6
\8\#\&{define} \.{PTL\_GA\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<vector>}\6
\8\#\&{include} \.{"ptl\_exc.h"}\6
\X11:Growing array (head)\X\6
\8\#\&{endif}\par
\fi

\M{11}Growing array. We need an automatically growing array of given type.
We want to add to the array mostly, deallocating is done at the end of
work. The growing array is addressed by linear address and it grows when
addressing previously unaccessed member. Addressing is done with
overloaded `[\,]' operator.

We implement it as a vector of members. When a new member is added, it
is initialized to the value given to the constructor. Therefore we need
the \&{Tmember} object to have a `$\K$' copy constructor.

The \&{Tindex} type is a type of array index (for avoiding compilation
warnings, and for historical reasons), \&{Tmember} is a type of member.

\Y\B\F\\{Tindex} \5
\\{int}\par
\B\F\\{Tmember} \5
\\{int}\par
\Y\B\4\X11:Growing array (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tmember}${}%
\rangle{}$\6
\&{class} \&{Growing\_array} :\6
\&{public} ${}\&{std}\DC\&{vector}\langle\&{Tmember}\rangle{}$ ${}\{{}$\1\6
\4\&{protected}:\6
\&{const} \&{Tmember} \\{default\_value};\7
\X12:Growing array: constructor\X\6
\X13:Growing array: operator[\,]\X\6
\X14:Growing array: print statistics\X\2\6
${}\}{}$;\par
\U10.\fi

\M{12}The constructor prepares the default value and constructs the vector.

\Y\B\4\X12:Growing array: constructor\X${}\E{}$\6
\4\&{public}:\6
\&{Growing\_array}(\&{const} \&{Tmember} ${}{\AND}\\{def\_val}){}$\1\1\2\2\6
: ${}\&{std}\DC\&{vector}\langle\&{Tmember}\rangle(\,),\39{}$ \\{default%
\_value}(\\{def\_val})\6
${}\{\,\}{}$\par
\U11.\fi

\M{13}Operator [\,] accesses the array like an usual array, if the accessed
member is not allocated, it prepares it.

\Y\B\4\X13:Growing array: operator[\,]\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{Tmember} ${}{\AND}{}$\&{operator}[\,](\&{const} \&{Tindex} ${}{%
\AND}\\{logical\_addr}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{try}\5
${}\{{}$\1\6
\&{while} ${}(\\{logical\_addr}\G\&{std}\DC\&{vector}\langle\&{Tmember}\rangle%
\DC\\{size}(\,)){}$\1\5
${}\&{std}\DC\&{vector}\langle\&{Tmember}\rangle\DC\\{push\_back}(\\{default%
\_value});{}$\2\6
\&{return} ${}\&{std}\DC\&{vector}\langle\&{Tmember}\rangle\DC\&{operator}[\,](%
\\{logical\_addr});{}$\6
\4${}\}{}$\2\7
${}\&{catch}(\,\ldots\,){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{cerr}\LL\\{endl}\LL\.{"!\ Growing\ array:\ er}\)\.{ror\ in\ []\
operator"}\LL\\{endl};{}$\6
${}\\{cerr}\LL\.{"\ \ Logical\ member\ re}\)\.{quested\ "}\LL\\{logical\_addr}%
\LL\\{endl};{}$\6
${}\\{cerr}\LL\.{"\ \ No.\ of\ members\ us}\)\.{ed\ \ \ \ \ \ "}\LL\&{std}\DC%
\&{vector}\langle\&{Tmember}\rangle\DC\\{size}(\,)\LL\\{endl};{}$\6
${}\\{cerr}\LL\.{"\ \ No.\ of\ members\ re}\)\.{served\ \ "}\LL\&{std}\DC%
\&{vector}\langle\&{Tmember}\rangle\DC\\{capacity}(\,)\LL\\{endl};{}$\6
${}\\{cerr}\LL\.{"\ \ Member\ size\ (byte}\)\.{s)\ \ \ \ \ \ "}\LL\&{sizeof}(%
\&{Tmember})\LL\\{endl};{}$\6
\&{throw} \&{Patlib\_error}(\.{""});\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U11.\fi

\M{14}Sometimes we want to know the statistics.

\Y\B\4\X14:Growing array: print statistics\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{print\_statistics}(\&{void}) \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\.{"\ \ No.\ of\ members\ us}\)\.{ed\ \ \ \ \ \ \ "}\LL\&{std}\DC%
\&{vector}\langle\&{Tmember}\rangle\DC\\{size}(\,)\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"\ \ No.\ of\ members\ re}\)\.{served\ \ \ "}\LL\&{std}\DC%
\&{vector}\langle\&{Tmember}\rangle\DC\\{capacity}(\,)\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"\ \ Member\ size\ (byte}\)\.{s)\ \ \ \ \ \ \ "}\LL\&{sizeof}(%
\&{Tmember})\LL\\{endl};{}$\6
\4${}\}{}$\2\par
\U11.\fi

\N{1}{15}Trie pattern manipulators. The trie pattern manipulator is a finite
language store, its offspring, candidate count trie, is only modified to
handle pairs of values easily.

\Y\B\4\X15:\.{ptl\_tpm.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_TPM\_H}\6
\8\#\&{define} \.{PTL\_TPM\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<vector>}\6
\8\#\&{include} \.{<set>}\6
\8\#\&{include} \.{"ptl\_exc.h"}\6
\8\#\&{include} \.{"ptl\_ga.h"}\6
\X16:Trie pattern manipulator (head)\X\6
\X37:Candidate count trie (head)\X\6
\8\#\&{endif}\par
\fi

\N{1}{16}Dynamic packed trie pattern manipulator. This is the implementation
of pattern manipulator.

For a pattern $p_1\ldots p_k$, the information associated with that
pattern is accessed by setting $t_1 = \\{trie\_root}+p_1$ and then, for
$1<i\le k$, setting $t_i = \\{trie\_link}[t_{i-1}] + p_i$. The pattern
output information is then stored in location addressed by $t_k$.
Therefore if the information is associated to a transition and/or there
is multiple output on various positions, the user must code this
knowledge into the output.

Since all trie nodes are packed into a single array, we use a special
field to distinguish nodes belonging to different families. Nodes belong
to one family if and only if $\\{trie\_char}(t_i) = p_i$ for all $i$.

In addition the trie must support dynamic insertions and deletions. This
is done by maintaining a doubly linked list of unoccupied cells and
repacking trie families as necessary when insertions are made.

Each trie node consists of following fields:

\item{$\bullet$} \\{trie\_char} is the character of input alphabet,
\item{$\bullet$} \\{trie\_link} points to the next field,
\item{$\bullet$} \\{trie\_back} points to the next free cell, unused if
position is used for a transition,
\item{$\bullet$} \\{trie\_outp} contains output of the pattern.

The types in the template must satisfy following conditions, if you
really want the template instantiation to be compiled:

\item 1 there must be commutative `+' operation defined between
\&{Tpm\_pointer} and \&{Tin\_alph} and the result must be of
\&{Tpm\_pointer} type,
\item 2 the \&{Tpm\_pointer} must be ordered and must satisfy
$0\le t$ for all used $t$ of \&{Tpm\_pointer}, the $0$ value
is special and must be represented as `nothing'
\item 3 the \&{Tin\_alph} must satisfy $0\le t\le$\\{max\_in\_alph} for all
used $t$
of \&{Tin\_alph} type, the $0$ value must not be used in pattern
\item 4 the \\{out\_inf\_zero} is a special value meaning `no output is
there'
\item 5 all the template types must have `=' copy constructor
\item 6 we recommend the \&{Tin\_alph} to be a subtype of \&{Tpm\_pointer},
\item 7 we recommend the types to be unsigned numeric ones and to
translate the application alphabet into numbers

(Still wanting to use anything else then numbers?)

\Y\B\F\\{Tpm\_pointer} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Tout\_information} \5
\\{int}\par
\Y\B\4\X16:Trie pattern manipulator (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tpm\_pointer}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tout\_information}${}\rangle{}$\6
\&{class} \&{Trie\_pattern\_manipulator} ${}\{{}$\1\6
\X17:Trie pattern manipulator: data structures\X\6
\X18:Trie pattern manipulator: gets and sets\X\7
\X19:Trie pattern manipulator: constructor\X\6
\X20:Trie pattern manipulator: destructor\X\7
\X21:Trie pattern manipulator: first fit\X\6
\X24:Trie pattern manipulator: unpack\X\7
\X25:Trie pattern manipulator: hard insert pattern\X\6
\X27:Trie pattern manipulator: walking through---data and init\X\6
\X28:Trie pattern manipulator: get next pattern\X\6
\X31:Trie pattern manipulator: word output\X\6
\X32:Trie pattern manipulator: word last output\X\6
\X33:Trie pattern manipulator: delete hanging\X\6
\X35:Trie pattern manipulator: set of my outputs\X\6
\X36:Trie pattern manipulator: print statistics\X\2\6
${}\}{}$;\par
\U15.\fi

\M{17}Data structures of the pattern manipulator:

\item{$\bullet$} \\{trie\_max} maximal used trie position

\item{$\bullet$} \\{trie\_bmax} maximal used base position

\item{$\bullet$} \\{trie\_count} number of occupied trie nodes, for statistics

\item{$\bullet$} \\{pat\_count} number of patterns in the trie, for statistics

\item{$\bullet$} \\{growing\_array}s having character, links to and fro,
boolean indicator whether the location is used as base and a field of
\&{Tout\_information} type used for various needed output and/or count
information.

\item{$\bullet$} \\{trieq\_} $*$ arrays for unpacking a state when repack is
needed and to pack a new state. The arrays are dynamic, initialized in
the constructor.

\item{$\bullet$} \\{q\_max\_thresh} value is used to decide where to pack the
state stored in \\{trieq\_} $*$ arrays. If this state is too dense, we pack it
to the end, otherwise we try to pack it among other states in trie.

\Y\B\4\X17:Trie pattern manipulator: data structures\X${}\E{}$\6
\4\&{protected}:\6
\&{enum} ${}\{{}$\1\6
${}\\{min\_in\_alph}\K\T{0}{}$\2\6
${}\}{}$;\SHC{ it's ugly, but it took me an hour to find out what the linker
means }\6
\&{enum} ${}\{{}$\1\6
${}\\{trie\_root}\K\T{1}{}$\2\6
${}\}{}$;\C{ this \&{enum} means the same as ``static const'' and this syntax
is more      portable }\6
\&{Tpm\_pointer} \\{trie\_max};\6
\&{Tpm\_pointer} \\{trie\_bmax};\6
\&{Tpm\_pointer} \\{trie\_count};\6
\&{Tpm\_pointer} \\{pat\_count};\7
\&{const} \&{Tin\_alph} \\{max\_in\_alph};\6
\&{const} \&{Tout\_information} \\{out\_inf\_zero};\7
${}\&{Growing\_array}\langle\&{Tpm\_pointer},\39\&{Tin\_alph}\rangle{}$ \\{trie%
\_char};\6
${}\&{Growing\_array}\langle\&{Tpm\_pointer},\39\&{Tpm\_pointer}\rangle{}$ %
\\{trie\_link};\6
${}\&{Growing\_array}\langle\&{Tpm\_pointer},\39\&{Tpm\_pointer}\rangle{}$ %
\\{trie\_back};\6
${}\&{Growing\_array}\langle\&{Tpm\_pointer},\39\&{char}\rangle{}$ \\{trie%
\_base\_used};\C{ one byte per a bit is a feasible solution (we cannot use
$\&{vector}\langle\&{bool}\rangle$) }\6
${}\&{Growing\_array}\langle\&{Tpm\_pointer},\39\&{Tout\_information}\rangle{}$
\\{trie\_outp};\7
\&{unsigned} \\{q\_max};\6
\&{unsigned} \\{q\_max\_thresh};\6
\&{Tin\_alph} ${}{*}\\{trieq\_char};{}$\6
\&{Tpm\_pointer} ${}{*}\\{trieq\_link};{}$\6
\&{Tpm\_pointer} ${}{*}\\{trieq\_back};{}$\6
\&{Tout\_information} ${}{*}\\{trieq\_outp}{}$;\par
\U16.\fi

\M{18}Several values may be obtained and set by users. The \\{q\_max\_thresh}
variable controls the \\{first\_fit} packing, the ``count'' variables are
for statistics only.

\Y\B\4\X18:Trie pattern manipulator: gets and sets\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{unsigned} \\{get\_q\_max\_thresh}(\&{void}) \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{q\_max\_thresh};\6
\4${}\}{}$\2\7
\&{virtual} \&{void} \\{set\_q\_max\_thresh}(\&{const} \&{unsigned} ${}{\AND}%
\\{new\_q\_m\_t}){}$\1\1\2\2\6
${}\{{}$\SHC{ \\{q\_max\_thresh} must be at least 1 (even though 1 is quite a
stupid choice) }\1\6
\&{if} ${}(\\{new\_q\_m\_t}>\T{0}){}$\1\5
${}\\{q\_max\_thresh}\K\\{new\_q\_m\_t};{}$\2\6
\4${}\}{}$\2\7
\&{virtual} \&{Tpm\_pointer} \\{get\_trie\_count}(\&{void}) \&{const}\SHC{ get
the number of occupied nodes }\6
${}\{{}$\1\6
\&{return} \\{trie\_count};\6
\4${}\}{}$\2\7
\&{virtual} \&{Tpm\_pointer} \\{get\_pat\_count}(\&{void}) \&{const}\SHC{ get
the number of patterns }\6
${}\{{}$\1\6
\&{return} \\{pat\_count};\6
\4${}\}{}$\2\7
\&{virtual} \&{Tpm\_pointer} \\{get\_max\_in\_alph}(\&{void}) \&{const}\SHC{
get the maximum input alphabet number }\6
${}\{{}$\1\6
\&{return} \\{max\_in\_alph};\6
\4${}\}{}$\2\par
\U16.\fi

\M{19}Initially, the dynamic packed trie has the only state, the root, with
all transitions present but with null links. We have to set up only the
\\{trie\_char} array as the other arrays are set to the default values when
initializating the arrays.

\Y\B\4\X19:Trie pattern manipulator: constructor\X${}\E{}$\6
\4\&{public}:\6
\&{Trie\_pattern\_manipulator}(\&{const} \&{Tin\_alph} ${}{\AND}\\{max\_i\_a},%
\39{}$\&{const} \&{Tout\_information} ${}{\AND}\\{out\_i\_z},\39{}$\&{const} %
\&{unsigned} ${}{\AND}\\{q\_thr}\K\T{5}){}$\1\1\2\2\6
:\SHC{ set default values to embedded objects }\6
\\{max\_in\_alph}(\\{max\_i\_a})${},\39{}$ \\{out\_inf\_zero}(\\{out\_i%
\_z})${},\39{}$ \\{trie\_char}(\\{min\_in\_alph})${},\39{}$ \\{trie\_link}(%
\\{min\_in\_alph})${},\39{}$ \\{trie\_back}(\\{min\_in\_alph})${},\39{}$ %
\\{trie\_base\_used}(\\{false})${},\39{}$ \\{trie\_outp}(\\{out\_inf%
\_zero})${},\39{}$ \\{q\_max\_thresh}(\\{q\_thr})\6
${}\{{}$\1\6
\&{for} (\&{Tpm\_pointer} \|c${}\K\\{min\_in\_alph};{}$ ${}\|c\Z\\{max\_in%
\_alph};{}$ ${}\|c\PP){}$\5
${}\{{}$\1\6
${}\\{trie\_char}[\\{trie\_root}+\|c]\K\|c;{}$\6
\4${}\}{}$\C{ In this cycle there was a very nice bug. The type of \|c was
  \&{Tin\_alph}. The problem appeared when \&{Tin\_alph} become        %
\&{unsigned} \&{char} and \\{max\_in\_alph} was 255. This makes infinite
cycle then\dots. This bug lived here more than half a year. BTW,        I
discovered it on Friday, 13 July 2001. And when writing this        text, my
Emacs dumped core. Strange :-) }\2\6
${}\\{trie\_base\_used}[\\{trie\_root}]\K\\{true};{}$\6
${}\\{trie\_bmax}\K\\{trie\_root};{}$\6
${}\\{trie\_max}\K\\{trie\_root}+\\{max\_in\_alph}{}$;\7
${}\\{trie\_count}\K\\{max\_in\_alph}+\T{1};{}$\6
${}\\{pat\_count}\K\T{0}{}$;\7
${}\\{trie\_link}[\T{0}]\K\\{trie\_max}+\T{1};{}$\6
${}\\{trie\_back}[\\{trie\_max}+\T{1}]\K\T{0}{}$;\7
${}\\{trieq\_char}\K{}$\&{new} \&{Tin\_alph}${}[\\{max\_in\_alph}+\T{1}]{}$;%
\SHC{ init trieq arrays }\6
${}\\{trieq\_link}\K{}$\&{new} \&{Tpm\_pointer}${}[\\{max\_in\_alph}+\T{1}];{}$%
\6
${}\\{trieq\_back}\K{}$\&{new} \&{Tpm\_pointer}${}[\\{max\_in\_alph}+\T{1}];{}$%
\6
${}\\{trieq\_outp}\K{}$\&{new} \&{Tout\_information}${}[\\{max\_in\_alph}+%
\T{1}];{}$\6
\4${}\}{}$\2\par
\U16.\fi

\M{20}We have to destroy dynamic arrays in the destructor.

\Y\B\4\X20:Trie pattern manipulator: destructor\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} ${}\CM\&{Trie\_pattern\_manipulator}(\,){}$\1\1\2\2\6
${}\{{}$\1\6
\&{delete}[\,] \\{trieq\_char};\6
\&{delete}[\,] \\{trieq\_link};\6
\&{delete}[\,] \\{trieq\_back};\6
\&{delete}[\,] \\{trieq\_outp};\6
\4${}\}{}$\2\par
\U16.\fi

\M{21}The \\{first\_fit} procedure find a hole on the packed trie into which
state in \\{trieq\_} $*$ arrays will fit. This is normally done by going
through the linked list of unoccupied cells and testing if the state
will fit at each position. However if the state is too dense, we just
pack it to the first unoccupied region (at $\\{trie\_max}+\T{1}$). The state is
considered dense if it has more than \\{q\_max\_thresh} states.

\Y\B\4\X21:Trie pattern manipulator: first fit\X${}\E{}$\6
\&{protected}:\6
\&{virtual} \&{Tpm\_pointer} \\{first\_fit}(\&{void})\1\1 $\{{}$\6
\&{unsigned} \&{int} \|q;\6
\&{Tpm\_pointer} \|s${},{}$ \|t;\7
\X22:Trie pattern manipulator: (first fit) set \|s to the trie base location at
which this state should be packed\X\SHC{ pack it }\6
\&{for} ${}(\|q\K\T{1};{}$ ${}\|q\Z\\{q\_max};{}$ ${}\|q\PP){}$\5
${}\{{}$\1\6
${}\|t\K\|s+\\{trieq\_char}[\|q]{}$;\SHC{ link around filled cell }\6
${}\\{trie\_link}[\\{trie\_back}[\|t]]\K\\{trie\_link}[\|t];{}$\6
${}\\{trie\_back}[\\{trie\_link}[\|t]]\K\\{trie\_back}[\|t];{}$\6
${}\\{trie\_char}[\|t]\K\\{trieq\_char}[\|q];{}$\6
${}\\{trie\_link}[\|t]\K\\{trieq\_link}[\|q];{}$\6
${}\\{trie\_back}[\|t]\K\\{trieq\_back}[\|q];{}$\6
${}\\{trie\_outp}[\|t]\K\\{trieq\_outp}[\|q];{}$\6
\&{if} ${}(\|t>\\{trie\_max}){}$\5
${}\{{}$\1\6
${}\\{trie\_max}\K\|t;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{trie\_base\_used}[\|s]\K\\{true};{}$\6
\&{return} \|s;\6
$\}{}$\par
\U16.\fi

\M{22}The threshold is used to decide what to do. We may pack the state to
the end of used region or pack it among other transitions.

\Y\B\4\X22:Trie pattern manipulator: (first fit) set \|s to the trie base
location at which this state should be packed\X${}\E{}$\6
\&{if} ${}(\\{q\_max}>\\{q\_max\_thresh}){}$\5
${}\{{}$\1\6
${}\|t\K\\{trie\_back}[\\{trie\_max}+\T{1}];{}$\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\|t\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{while} (\T{1}) $\{{}$\SHC{ I don't like goto, but do it efficiently without
it: }\6
$\|t\K\\{trie\_link}[\|t]{}$;\SHC{ get next unoccupied cell }\6
${}\|s\K\|t-\\{trieq\_char}[\T{1}]{}$;\6
\X23:Trie pattern manipulator: (first fit) ensure \\{trie} linked up to $\|s+%
\\{max\_in\_alph}+\T{1}$\X \6
\&{if} (\\{trie\_base\_used}[\|s])\5
${}\{{}$\1\6
\&{goto} \\{not\_found};\6
\4${}\}{}$\2\6
\&{for} ${}(\|q\K\\{q\_max};{}$ ${}\|q\G\T{2};{}$ ${}\|q\MM){}$\5
${}\{{}$\SHC{ check if state fits there }\1\6
\&{if} ${}(\\{trie\_char}[\|s+\\{trieq\_char}[\|q]]\I\\{min\_in\_alph}){}$\5
${}\{{}$\1\6
\&{goto} \\{not\_found};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{goto} \\{found};\6
\4\\{not\_found}:\5
;\SHC{ go to the next loop }\6
$\}$ \6
\4\\{found}:\5
;\par
\U21.\fi

\M{23}The trie is only initialized (as a doubly linked list of empty cells)
as far as necessary. Here we extend the initialization.

\Y\B\4\X23:Trie pattern manipulator: (first fit) ensure \\{trie} linked up to $%
\|s+\\{max\_in\_alph}+\T{1}$\X${}\E{}$\6
\&{while} ${}(\\{trie\_bmax}<\|s){}$\5
${}\{{}$\1\6
${}\\{trie\_bmax}\PP;{}$\6
${}\\{trie\_base\_used}[\\{trie\_bmax}]\K\\{false};{}$\6
${}\\{trie\_char}[\\{trie\_bmax}+\\{max\_in\_alph}]\K\\{min\_in\_alph};{}$\6
${}\\{trie\_outp}[\\{trie\_bmax}+\\{max\_in\_alph}]\K\\{out\_inf\_zero}{}$;%
\SHC{ is this necessary? it is done by growing array! }\6
${}\\{trie\_link}[\\{trie\_bmax}+\\{max\_in\_alph}]\K\\{trie\_bmax}+\\{max\_in%
\_alph}+\T{1};{}$\6
${}\\{trie\_back}[\\{trie\_bmax}+\\{max\_in\_alph}+\T{1}]\K\\{trie\_bmax}+%
\\{max\_in\_alph};{}$\6
\4${}\}{}$\2\par
\U22.\fi

\M{24}The \\{unpack} procedure finds all transitions associated with the state
based on \|s and puts them into \\{trieq\_} $*$ arrays and sets \\{q\_max} to
one
more than the number of transitions found. Freed cells are put at the
beginning of the free list.

\Y\B\4\X24:Trie pattern manipulator: unpack\X${}\E{}$\6
\4\&{protected}:\6
\&{virtual} \&{void} \\{unpack}(\&{const} \&{Tpm\_pointer} ${}{\AND}\|s){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{Tpm\_pointer} \|t;\7
${}\\{q\_max}\K\T{1};{}$\6
\&{for} (\&{Tpm\_pointer} \|c${}\K\\{min\_in\_alph};{}$ ${}\|c\Z\\{max\_in%
\_alph};{}$ ${}\|c\PP){}$\5
${}\{{}$\1\6
${}\|t\K\|s+\|c;{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\E\|c\W\|c\I\\{min\_in\_alph}){}$\5
${}\{{}$\SHC{ found one }\1\6
${}\\{trieq\_char}[\\{q\_max}]\K\|c;{}$\6
${}\\{trieq\_link}[\\{q\_max}]\K\\{trie\_link}[\|t];{}$\6
${}\\{trieq\_back}[\\{q\_max}]\K\\{trie\_back}[\|t];{}$\6
${}\\{trieq\_outp}[\\{q\_max}]\K\\{trie\_outp}[\|t];{}$\6
${}\\{q\_max}\PP{}$;\SHC{ now free trie node }\6
${}\\{trie\_back}[\\{trie\_link}[\T{0}]]\K\|t;{}$\6
${}\\{trie\_link}[\|t]\K\\{trie\_link}[\T{0}];{}$\6
${}\\{trie\_link}[\T{0}]\K\|t;{}$\6
${}\\{trie\_back}[\|t]\K\T{0};{}$\6
${}\\{trie\_char}[\|t]\K\\{min\_in\_alph};{}$\6
${}\\{trie\_outp}[\|t]\K\\{out\_inf\_zero}{}$;\SHC{ not needed }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{trie\_base\_used}[\|s]\K\\{false};{}$\6
\4${}\}{}$\2\par
\U16.\fi

\M{25}Here is a procedure that inserts a pattern into the pattern trie. The
pattern is a \&{vector} of \&{Tin\_alph} symbols and adjacent
\&{Tout\_information} is put to the end of the pattern in the trie.

By hard inserting we mean that previous output is rewritten. We
sometimes want to add to the output, so we have to get the last output
of the word, change the output and ``hard'' insert it back.

\Y\B\4\X25:Trie pattern manipulator: hard insert pattern\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{void} \\{hard\_insert\_pattern}(\&{const} ${}\&{vector}\langle%
\&{Tin\_alph}\rangle{}$ ${}{\AND}\|w,\39{}$\&{const} \&{Tout\_information} ${}{%
\AND}\|o){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\|w.\\{empty}(\,)){}$\1\5
\&{return};\C{ if you want to insert a void pattern, we
    will ignore you }\2\7
\&{Tpm\_pointer} \|s${},{}$ \|t;\6
${}\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{const\_iterator}{}$ \|i${}\K\|w.%
\\{begin}(\,);{}$\7
${}\|s\K\\{trie\_root}+{*}\|i;{}$\6
${}\|t\K\\{trie\_link}[\|s]{}$;\7
\&{while} ${}((\|t>\T{0})\W((\|i+\T{1})\I\|w.\\{end}(\,))){}$\5
${}\{{}$\SHC{ follow existing trie }\1\6
${}\|i\PP;{}$\6
${}\|t\MRL{+{\K}}{*}\|i;{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\I{*}\|i){}$\5
${}\{{}$\1\6
\X26:Trie pattern manipulator: (hard insert pattern) insert critical
transition, possibly repacking\X\6
\4${}\}{}$\2\6
${}\|s\K\|t;{}$\6
${}\|t\K\\{trie\_link}[\|s];{}$\6
\4${}\}{}$\2\6
${}\\{trieq\_link}[\T{1}]\K\T{0};{}$\6
${}\\{trieq\_back}[\T{1}]\K\T{0};{}$\6
${}\\{trieq\_outp}[\T{1}]\K\\{out\_inf\_zero};{}$\6
${}\\{q\_max}\K\T{1}{}$;\7
\&{while} ${}((\|i+\T{1})\I\|w.\\{end}(\,)){}$\5
${}\{{}$\SHC{ insert rest of pattern }\1\6
${}\|i\PP;{}$\6
${}\\{trieq\_char}[\T{1}]\K{*}\|i;{}$\6
${}\|t\K\\{first\_fit}(\,);{}$\6
${}\\{trie\_link}[\|s]\K\|t;{}$\6
${}\|s\K\|t+{*}\|i;{}$\6
${}\\{trie\_count}\PP;{}$\6
\4${}\}{}$\2\7
\&{if} ${}((\\{trie\_outp}[\|s]\E\\{out\_inf\_zero})\W(\|o\I\\{out\_inf%
\_zero})){}$\5
${}\{{}$\SHC{ we rewrite ``no-pattern'' by ``pattern'' }\1\6
${}\\{pat\_count}\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}((\\{trie\_outp}[\|s]\I\\{out\_inf\_zero})\W(\|o\E\\{out\_inf%
\_zero})){}$\5
${}\{{}$\SHC{ we rewrite ``pattern'' by ``no-pattern'', we delete in fact }\1\6
${}\\{pat\_count}\MM;{}$\6
\4${}\}{}$\2\7
${}\\{trie\_outp}[\|s]\K\|o;{}$\6
\4${}\}{}$\2\par
\U16.\fi

\M{26}We have accessed transition not in the trie. We insert it, repacking
the state if necessary.

\Y\B\4\X26:Trie pattern manipulator: (hard insert pattern) insert critical
transition, possibly repacking\X${}\E{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\E\\{min\_in\_alph}){}$\5
${}\{{}$\SHC{ no repacking needed }\1\6
${}\\{trie\_link}[\\{trie\_back}[\|t]]\K\\{trie\_link}[\|t];{}$\6
${}\\{trie\_back}[\\{trie\_link}[\|t]]\K\\{trie\_back}[\|t];{}$\6
${}\\{trie\_char}[\|t]\K{*}\|i;{}$\6
${}\\{trie\_link}[\|t]\K\T{0};{}$\6
${}\\{trie\_back}[\|t]\K\T{0};{}$\6
${}\\{trie\_outp}[\|t]\K\\{out\_inf\_zero};{}$\6
\&{if} ${}(\|t>\\{trie\_max}){}$\5
${}\{{}$\1\6
${}\\{trie\_max}\K\|t;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\SHC{ whoops, have to repack }\1\6
${}\\{unpack}(\|t-{*}\|i);{}$\6
${}\\{trieq\_char}[\\{q\_max}]\K{*}\|i;{}$\6
${}\\{trieq\_link}[\\{q\_max}]\K\T{0};{}$\6
${}\\{trieq\_back}[\\{q\_max}]\K\T{0};{}$\6
${}\\{trieq\_outp}[\\{q\_max}]\K\\{out\_inf\_zero};{}$\6
${}\|t\K\\{first\_fit}(\,);{}$\6
${}\\{trie\_link}[\|s]\K\|t;{}$\6
${}\|t\MRL{+{\K}}{*}\|i;{}$\6
\4${}\}{}$\2\6
${}\\{trie\_count}\PP{}$;\par
\U25.\fi

\M{27}Walking through the pattern manipulator language. This is something
like an ``iterator'', we init walk through and then we may get patterns
and their outputs iteratively, one by one. We use a stack where we store
current path in the manipulator. The \\{init\_walk\_through} procedure sets
the initial stack values to start searching.

\Y\B\4\X27:Trie pattern manipulator: walking through---data and init\X${}\E{}$\6
\4\&{protected}:\6
${}\&{vector}\langle\&{Tpm\_pointer}\rangle{}$ \\{pointer\_stack};\6
${}\&{vector}\langle\&{Tpm\_pointer}\rangle{}$ \\{char\_stack};\7
\4\&{public}:\6
\&{virtual} \&{void} \\{init\_walk\_through}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{pointer\_stack}.\\{clear}(\,);{}$\6
${}\\{char\_stack}.\\{clear}(\,);{}$\6
${}\\{pointer\_stack}.\\{push\_back}(\\{trie\_root});{}$\6
${}\\{char\_stack}.\\{push\_back}(\\{min\_in\_alph});{}$\6
\4${}\}{}$\2\par
\U16.\fi

\M{28}Getting the next pattern is here. When we reach state having output we
stop depth-first-search and return the values. When \\{get\_next\_pattern}
is called again, it finds next pattern. If find was successful, \\{true}
is returned by \\{get\_next\_pattern}, otherwise \\{false}. It allows to use
construction \&{while} ${}(\\{get\_next\_pattern}(\,\ldots\,))$. The pattern
and its output
is returned in \|w and \|o variables. Moreover when no more pattern
remains (\\{false} is returned), the \|w vector is emptied and \|o is set
to \\{out\_inf\_zero}.

Important: Inserting and deleting patterns may interfere with the
walk-through process. Nevertheless you may change the output of an {\it
existing\/} pattern independently on the walk-through process using
\\{hard\_insert\_pattern}.

And never forget to use \\{init\_walk\_through} first!

\Y\B\4\X28:Trie pattern manipulator: get next pattern\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{bool} ${}\\{get\_next\_pattern}(\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39{}$\&{Tout\_information} ${}{\AND}\|o){}$\1\1\2\2\6
${}\{{}$\1\6
\&{Tpm\_pointer} \|t${},{}$ \\{tstart};\6
\&{Tpm\_pointer} \|c${},{}$ \\{cstart};\7
${}\|w.\\{clear}(\,);{}$\6
${}\|o\K\\{out\_inf\_zero}{}$;\7
\&{while} (\\{true})\5
${}\{{}$\1\6
\&{if} ${}(\\{pointer\_stack}.\\{empty}(\,)){}$\1\5
\&{return} \\{false};\2\6
${}\\{tstart}\K\\{pointer\_stack}.\\{back}(\,);{}$\6
${}\\{pointer\_stack}.\\{pop\_back}(\,){}$;\C{ we have
                                       where to
                                go }\6
${}\\{cstart}\K\\{char\_stack}.\\{back}(\,);{}$\6
${}\\{char\_stack}.\\{pop\_back}(\,){}$;\7
\&{for} ${}(\|c\K\\{cstart};{}$ ${}\|c\Z\\{max\_in\_alph};{}$ ${}\|c\PP){}$\5
${}\{{}$\SHC{ find transitions belonging to this family }\1\6
${}\|t\K\\{tstart}+\|c{}$;\7
\&{if} ${}(\\{trie\_char}[\|t]\E\|c\W\|c\I\\{min\_in\_alph}){}$\5
${}\{{}$\SHC{ found one }\1\6
${}\\{pointer\_stack}.\\{push\_back}(\\{tstart});{}$\6
${}\\{char\_stack}.\\{push\_back}(\|c+\T{1});{}$\6
\&{if} ${}(\\{trie\_outp}[\|t]\I\\{out\_inf\_zero}){}$\5
${}\{{}$\SHC{ state with output }\1\6
\X30:Trie pattern manipulator: (get next pattern) output the pattern and
belonging output\X\SHC{ state found successfully }\6
\X29:Trie pattern manipulator: (get next pattern) go deeper if possible\X\6
\&{return} \\{true};\6
\4${}\}{}$\2\6
\X29:Trie pattern manipulator: (get next pattern) go deeper if possible\X\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U16.\fi

\M{29}Prepare the way to go deeper in the trie.

\Y\B\4\X29:Trie pattern manipulator: (get next pattern) go deeper if possible%
\X${}\E{}$\6
\&{if} ${}(\\{trie\_link}[\|t]\I\T{0}){}$\5
${}\{{}$\SHC{ we have to go deeper, if possible }\1\6
${}\\{pointer\_stack}.\\{push\_back}(\\{trie\_link}[\|t]);{}$\6
${}\\{char\_stack}.\\{push\_back}(\\{min\_in\_alph});{}$\6
\4${}\}{}$\2\par
\U28.\fi

\M{30}We have come to the end of a pattern, so we now output it. We fill the
\|w vector with the pattern and the \|o with the output of the pattern.

Note that the last stack value is ignored by this routine as it shows
where to go next. The value in \\{char\_stack} is the character plus one.

\Y\B\4\X30:Trie pattern manipulator: (get next pattern) output the pattern and
belonging output\X${}\E{}$\6
$\&{vector}\langle\&{Tpm\_pointer}\rangle\DC\&{iterator}{}$ \\{it}${}\K%
\\{pointer\_stack}.\\{begin}(\,);{}$\6
${}\&{vector}\langle\&{Tpm\_pointer}\rangle\DC\&{iterator}{}$ \\{ic}${}\K%
\\{char\_stack}.\\{begin}(\,);{}$\6
\&{Tpm\_pointer} \|u;\SHC{ now let's go to the last-to-end stack character }\7
\&{for} (\&{Tpm\_pointer} \|i${}\K\T{0};{}$ ${}\|i<\\{pointer\_stack}.\\{size}(%
\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\|u\K({*}\\{it})+\&{Tpm\_pointer}({*}\\{ic})-\T{1}{}$;\SHC{ in stack, there
is one more }\6
${}\|w.\\{push\_back}(\\{trie\_char}[\|u]);{}$\6
${}\\{it}\PP;{}$\6
${}\\{ic}\PP;{}$\6
\4${}\}{}$\2\6
${}\|o\K\\{trie\_outp}[\|u]{}$;\par
\U28.\fi

\M{31}This is a procedure to produce output of pattern on given word. All
outputs of patterns matching the beginning of the \|w are pushed back to
the \|o vector to the same position. If no output is associated with
this transition, \|o vector is filled with \\{out\_inf\_zero}. If the \|w is
longer than any matching pattern, the \|o vector is filled to the same
length with the \\{out\_inf\_zero} value.

Note that this is not the same as ``hyphenate'' procedure, we need to
use \\{word\_output} with all postfixes of the word to get complete
information. This function must nevertheless be implemented in
application layer of pattern generator as the pattern manipulator does
not know anything about the semantics of output information. So we are
not able to make the patterns outputs compete here, we do not know the
order of the symbols.

\Y\B\4\X31:Trie pattern manipulator: word output\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{word\_output}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}\rangle{}$
${}{\AND}\|w,\39\&{vector}\langle\&{Tout\_information}\rangle{}$ ${}{\AND}%
\|o){}$\1\1\2\2\6
${}\{{}$\1\6
\&{Tpm\_pointer} \|t;\6
${}\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{const\_iterator}{}$ \|i${}\K\|w.%
\\{begin}(\,);{}$\7
${}\|o.\\{clear}(\,){}$;\7
\&{if} ${}(\|w.\\{empty}(\,)){}$\1\5
\&{return};\2\7
${}\|t\K\\{trie\_root}{}$;\7
\&{do}\5
${}\{{}$\SHC{ follow trie and get the outputs }\1\6
${}\|t\MRL{+{\K}}{*}\|i;{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\E{*}\|i){}$\1\5
${}\|o.\\{push\_back}(\\{trie\_outp}[\|t]);{}$\2\6
\&{else}\1\5
\&{break};\2\6
${}\|t\K\\{trie\_link}[\|t];{}$\6
${}\|i\PP;{}$\6
\4${}\}{}$\2\5
\&{while} ${}(\|t\I\T{0}\W\|i\I\|w.\\{end}(\,)){}$;\7
\&{while} ${}(\|i\I\|w.\\{end}(\,)){}$\5
${}\{{}$\SHC{ fill outputs to the same length }\1\6
${}\|o.\\{push\_back}(\\{out\_inf\_zero});{}$\6
${}\|i\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U16.\fi

\M{32}This procedure gives only the last output of a word. It is equivalent
to previous procedure if you use only the last field of \|o vector, but
this is optimized.

So the last output is given, if no output of the word exists,
\\{out\_inf\_zero} is returned.

\Y\B\4\X32:Trie pattern manipulator: word last output\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{word\_last\_output}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39{}$\&{Tout\_information} ${}{\AND}\|o){}$\1\1\2\2\6
${}\{{}$\6
\8\#\&{if} ${}\T{0}\E{}$\T{1}\SHC{ unoptimized version }\1\6
${}\|o\K\\{out\_inf\_zero};{}$\7
${}\&{vector}\langle\&{Tout\_information}\rangle{}$ \\{whole\_o};\7
${}\\{word\_output}(\|w,\39\\{whole\_o});{}$\6
\&{if} ${}(\\{whole\_o}.\\{size}(\,)\G\T{1}){}$\1\5
${}\|o\K{*}(\\{whole\_o}.\\{end}(\,)-\T{1});{}$\2\6
\8\#\&{endif}\7
\&{Tpm\_pointer} \|s${},{}$ \|t;\6
${}\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{const\_iterator}{}$ \|i${}\K\|w.%
\\{begin}(\,);{}$\7
${}\|o\K\\{out\_inf\_zero}{}$;\7
\&{if} ${}(\|w.\\{empty}(\,)){}$\1\5
\&{return};\2\7
${}\|t\K\\{trie\_root}{}$;\SHC{ follow the trie }\6
\&{do}\5
${}\{{}$\1\6
${}\|t\MRL{+{\K}}{*}\|i;{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\E{*}\|i){}$\1\5
${}\|s\K\|t;{}$\2\6
\&{else}\1\5
\&{break};\2\6
${}\|t\K\\{trie\_link}[\|t];{}$\6
${}\|i\PP;{}$\6
\4${}\}{}$\2\5
\&{while} ${}(\|t\I\T{0}\W\|i\I\|w.\\{end}(\,)){}$;\SHC{ if we are at the end
of the word, we have the output }\6
\&{if} ${}(\|i\E\|w.\\{end}(\,)){}$\5
${}\{{}$\1\6
${}\|o\K\\{trie\_outp}[\|s];{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U16.\fi

\M{33}We delete patterns by overwriting their outputs by \\{out\_inf\_zero}.
Hanging parts of patterns stay in their places. They may be removed at
once if we want to reduce the number of occupied cells. The
\\{delete\_hanging} procedure removes the nodes which have no output or
continue by branches with no output.

The following recursive procedure is a subroutine run from the root node of
the trie by
public-accessible procedure \\{delete\_hanging} and returns \\{true} if and
only if entire subtrie is removed.

\Y\B\4\X33:Trie pattern manipulator: delete hanging\X${}\E{}$\6
\4\&{private}:\6
\&{virtual} \&{bool} \\{delete\_hanging\_level}(\&{const} \&{Tpm\_pointer} ${}{%
\AND}\|s){}$\1\1\2\2\6
${}\{{}$\1\6
\&{Tpm\_pointer} \|t;\6
\&{bool} \\{all\_freed};\7
${}\\{all\_freed}\K\\{true};{}$\6
\&{for} (\&{Tpm\_pointer} \|c${}\K\\{min\_in\_alph};{}$ ${}\|c\Z\\{max\_in%
\_alph};{}$ ${}\|c\PP){}$\5
${}\{{}$\SHC{ find transitions belonging to this family }\1\6
${}\|t\K\|s+\|c;{}$\6
\&{if} ${}(\\{trie\_char}[\|t]\E\|c\W\|c\I\\{min\_in\_alph}){}$\5
${}\{{}$\SHC{ found one }\1\6
\&{if} ${}(\\{trie\_link}[\|t]\I\T{0}){}$\5
${}\{{}$\1\6
\&{if} (\\{delete\_hanging\_level}(\\{trie\_link}[\|t]))\1\5
${}\\{trie\_link}[\|t]\K\T{0};{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}((\\{trie\_link}[\|t]\I\T{0})\V(\\{trie\_outp}[\|t]\I\\{out\_inf%
\_zero})\V(\|s\E\\{trie\_root})){}$\1\5
${}\\{all\_freed}\K\\{false};{}$\2\6
\&{else}\1\5
\X34:Trie pattern manipulator: (delete hanging) deallocate this node\X\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} (\\{all\_freed})\5
${}\{{}$\SHC{ entire state is freed }\1\6
${}\\{trie\_base\_used}[\|s]\K\\{false};{}$\6
\4${}\}{}$\2\6
\&{return} \\{all\_freed};\6
\4${}\}{}$\2\7
\4\&{public}:\6
\&{virtual} \&{void} \\{delete\_hanging}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\\{delete\_hanging\_level}(\\{trie\_root});\6
\4${}\}{}$\2\par
\U16.\fi

\M{34}Cells freed by \\{delete\_hanging\_level} are put at the end of the free
list.

\Y\B\4\X34:Trie pattern manipulator: (delete hanging) deallocate this node\X${}%
\E{}$\6
${}\{{}$\1\6
${}\\{trie\_link}[\\{trie\_back}[\\{trie\_max}+\T{1}]]\K\|t;{}$\6
${}\\{trie\_back}[\|t]\K\\{trie\_back}[\\{trie\_max}+\T{1}];{}$\6
${}\\{trie\_link}[\|t]\K\\{trie\_max}+\T{1};{}$\6
${}\\{trie\_back}[\\{trie\_max}+\T{1}]\K\|t;{}$\6
${}\\{trie\_char}[\|t]\K\\{min\_in\_alph};{}$\6
${}\\{trie\_count}\MM;{}$\6
\4${}\}{}$\2\par
\U33.\fi

\M{35}We sometimes need to know all the outputs used in the pattern
manipulator. We may need it for example to clean complicated output
object which are no longer referenced. The $\&{set}\langle\&{Tout\_information}%
\rangle$ is
first cleared and then filled up with all the values used as outputs.

\Y\B\4\X35:Trie pattern manipulator: set of my outputs\X${}\E{}$\6
\4\&{public}:\6
\&{void} ${}\\{set\_of\_my\_outputs}(\&{set}\langle\&{Tout\_information}%
\rangle{}$ ${}{\AND}\|s){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|s.\\{clear}(\,);{}$\6
\&{for} (\&{Tpm\_pointer} \|i${}\K\T{0};{}$ ${}\|i\Z\\{trie\_max};{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\|s.\\{insert}(\\{trie\_outp}[\|i]);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U16.\fi

\M{36}Print statistics on trie structure. If \\{detail} is non-zero,
statistics on manipulator internal structures are also printed.

\Y\B\4\X36:Trie pattern manipulator: print statistics\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{print\_statistics}(\&{int} \\{detail}${}\K\T{0}){}$ \&{const}\1\1\2%
\2\6
${}\{{}$\1\6
${}\\{cout}\LL\.{"\ \ nodes:\ \ \ \ \ \ \ \ \ \ \ }\)\.{\ \ \ \ \ \ \ \ \ \ \ \
\ \ \ \ "}\LL\\{trie\_count}\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"\ \ patterns:\ \ \ \ \ \ \ \ }\)\.{\ \ \ \ \ \ \ \ \ \ \ \ \ %
\ \ \ "}\LL\\{pat\_count}\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"\ \ trie\_max:\ \ \ \ \ \ \ \ }\)\.{\ \ \ \ \ \ \ \ \ \ \ \ \
\ \ \ "}\LL\\{trie\_max}\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"\ \ current\ q\_max\_thr}\)\.{esh:\ \ \ \ \ \ \ \ \ \ \ \ "}%
\LL\\{q\_max\_thresh}\LL\\{endl};{}$\6
\&{if} (\\{detail})\5
${}\{{}$\1\6
${}\\{cout}\LL\.{"Trie\ char"}\LL\\{endl};{}$\6
${}\\{trie\_char}.\\{print\_statistics}(\,);{}$\6
${}\\{cout}\LL\.{"Trie\ link"}\LL\\{endl};{}$\6
${}\\{trie\_link}.\\{print\_statistics}(\,);{}$\6
${}\\{cout}\LL\.{"Trie\ back"}\LL\\{endl};{}$\6
${}\\{trie\_back}.\\{print\_statistics}(\,);{}$\6
${}\\{cout}\LL\.{"Trie\ base\ used"}\LL\\{endl};{}$\6
${}\\{trie\_base\_used}.\\{print\_statistics}(\,);{}$\6
${}\\{cout}\LL\.{"Trie\ outp"}\LL\\{endl};{}$\6
${}\\{trie\_outp}.\\{print\_statistics}(\,);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U16.\fi

\N{1}{37}Candidate count trie. This trie is to collect statistics about the
patterns generated in the current level.

The most useful statistics (and the statistics we use) is the pair of
numbers \\{good} and \\{bad}, meaning the number of cases when the candidate
pattern works well or badly in the context of patterns collected so far.

The main reason of providing this service is to hide uncomfortable work
with pairs of values.

We suppose the candidate patterns stored in the count trie at the same
time to have the same length and to be about the only position of
interest. This condition is useful for us as it allows to simplify
candidate pattern handling rapidly. We would have to have multiple
outputs for a pattern and store information on what position the output
is related to. It would also make some optimizations, namely ``knocking
out'', much more complicated.

The \&{Tcount\_good} and \&{Tcount\_bad} template argument is a number type of
\\{good} and \\{bad} values. For information on the other arguments see the
\&{Trie\_pattern\_manipulator} definition.

\Y\B\F\\{Tpm\_pointer} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Tcount\_good} \5
\\{int}\par
\B\F\\{Tcount\_bad} \5
\\{int}\par
\Y\B\4\X37:Candidate count trie (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tpm\_pointer}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tcount\_good}${},\39{}$\&{class} \&{Tcount%
\_bad}${}\rangle{}$\6
\&{class} \&{Candidate\_count\_trie} :\6
\&{public} ${}\&{Trie\_pattern\_manipulator}\langle\&{Tpm\_pointer},\39\&{Tin%
\_alph},\39\&{pair}\langle\&{Tcount\_good},\39\&{Tcount\_bad}\rangle\rangle{}$
${}\{{}$\1\6
\4\&{public}:\6
\&{typedef} ${}\&{pair}\langle\&{Tcount\_good},\39\&{Tcount\_bad}\rangle{}$ %
\&{Tcount\_pair};\7
\X38:Candidate count trie: constructor\X\6
\X39:Candidate count trie: increment counts\X\6
\X40:Candidate count trie: get next pattern\X\2\6
${}\}{}$;\par
\U15.\fi

\M{38}We have to initialize the default values. The default packing
threshold is less (at least we recommend it) then in
\&{Trie\_pattern\_manipulator} as speed is more important here.

\Y\B\4\X38:Candidate count trie: constructor\X${}\E{}$\6
\4\&{public}:\6
\&{Candidate\_count\_trie}(\&{const} \&{Tin\_alph} ${}{\AND}\\{max\_i\_a},%
\39{}$\&{const} \&{Tcount\_good} ${}{\AND}\\{out\_i\_z\_good},\39{}$\&{const} %
\&{Tcount\_bad} ${}{\AND}\\{out\_i\_z\_bad},\39{}$\&{const} \&{unsigned} ${}{%
\AND}\\{q\_thr}\K\T{3}){}$\1\1\2\2\6
: ${}\&{Trie\_pattern\_manipulator}\langle\&{Tpm\_pointer},\39\&{Tin\_alph},\39%
\&{Tcount\_pair}\rangle(\\{max\_i\_a},\39\\{make\_pair}(\\{out\_i\_z\_good},\39%
\\{out\_i\_z\_bad}),\39\\{q\_thr}{}$)\6
${}\{\,\}{}$\par
\U37.\fi

\M{39}The following procedures increment the good and the bad counts in
patterns. If you want to change the only one parameter, change the other
with zero :-). If the pattern has not been in the trie, it is inserted
and the counts are added to the default values.

The procedure may be optimized, we may manipulate the data directly. In
the way we do it the trie must be traversed twice. This is conceptually
nicer.

\Y\B\4\X39:Candidate count trie: increment counts\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{void} \\{increment\_counts}(\&{const} ${}\&{vector}\langle\&{Tin%
\_alph}\rangle{}$ ${}{\AND}\|w,\39{}$\&{const} \&{Tcount\_good} ${}{\AND}%
\\{good\_inc},\39{}$\&{const} \&{Tcount\_bad} ${}{\AND}\\{bad\_inc}){}$\1\1\2\2%
\6
${}\{{}$\1\6
\&{Tcount\_pair} \\{counts};\7
${}\\{word\_last\_output}(\|w,\39\\{counts});{}$\6
${}\\{counts}.\\{first}\MRL{+{\K}}\\{good\_inc};{}$\6
${}\\{counts}.\\{second}\MRL{+{\K}}\\{bad\_inc};{}$\6
${}\\{hard\_insert\_pattern}(\|w,\39\\{counts}){}$;\C{ now we overwrite the
output or                                      insert it if it was void }\6
\4${}\}{}$\2\par
\U37.\fi

\M{40}Get next pattern overloads the procedure from the
\&{Trie\_pattern\_manipulator}, the \\{good} and \\{bad} counts are returned
instead of a pair of them. Please see discussion on the original method
to learn how to use it. Do not forget to run \\{init\_walk\_through} first!

\Y\B\4\X40:Candidate count trie: get next pattern\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{bool} ${}\\{get\_next\_pattern}(\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39{}$\&{Tcount\_good} ${}{\AND}\\{good},\39{}$%
\&{Tcount\_bad} ${}{\AND}\\{bad}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{Tcount\_pair} \\{counts};\6
\&{bool} \\{ret\_val};\7
${}\\{ret\_val}\K\&{Trie\_pattern\_manipulator}\langle\&{Tpm\_pointer},\39%
\&{Tin\_alph},\39\&{pair}\langle\&{Tcount\_good},\39\&{Tcount\_bad}\rangle%
\rangle\DC\\{get\_next\_pattern}(\|w,\39\\{counts});{}$\6
${}\\{good}\K\\{counts}.\\{first};{}$\6
${}\\{bad}\K\\{counts}.\\{second};{}$\6
\&{return} \\{ret\_val};\6
\4${}\}{}$\2\par
\U37.\fi

\N{1}{41}Multiple output pattern handling. The pattern manipulators we have
seen in previous sections are able to keep the only (well, sometimes a
pair of) thing as the output. But we need outputs on different positions
of a word. Therefore we provide simple methods to keep outputs of word
positions and the manipulator with such kind of language.

\Y\B\4\X41:\.{ptl\_mopm.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_MOPM\_H}\6
\8\#\&{define} \.{PTL\_MOPM\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<map>}\6
\8\#\&{include} \.{<set>}\6
\8\#\&{include} \.{"ptl\_tpm.h"}\6
\X42:Outputs of a pattern (head)\X\6
\X43:Outputs of patterns (head)\X\6
\X44:Multi output pattern manipulator (head)\X\6
\X57:Competitive multi out pat manip (head)\X\6
\8\#\&{endif}\par
\fi

\N{1}{42}Multiple pattern outputs. The pattern manipulator recognizes the end
of a word by having the output on that position. We have to store
information on what position of the pattern the output is related to,
e.g.~the pattern is $qwerty(2,4)$ means that the pattern $qwerty$ has
output~$4$ after the second character, the usual form of writing this
is~$qw4erty$.

Another complication is that the input word may have several outputs, so
we have to store {\it sets\/} of outputs instead of the outputs
themselves. If we have pattern~$qw4ert5y$, we store it
as~$qwerty\{(2,4),(5,5)\}$ into the manipulator.

We will do it really easily, we inherit all the operations we need from
the standard container \&{multimap}. The \&{Tposition} is the position in a
pattern (convention: the output before the first character is 0th, after
the first character is 1st and so on). The \&{Toutput} is the real output
of the position.

\Y\B\F\\{Tposition} \5
\\{int}\par
\B\F\\{Toutput} \5
\\{int}\par
\Y\B\4\X42:Outputs of a pattern (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tposition}${},\39{}$\&{class} %
\&{Toutput}${}\rangle{}$\6
\&{class} \&{Outputs\_of\_a\_pattern} :\6
\&{public} ${}\&{std}\DC\&{multimap}\langle\&{Tposition},\39\&{Toutput}%
\rangle{}$\6
${}\{\,\}{}$;\par
\U41.\fi

\M{43}We have not said the whole story yet. We may now store the previous
objects as outputs of the \&{Trie\_pattern\_manipulator}. But the
\&{Outputs\_of\_a\_pattern} objects are quite large and there will not be a
lot of different ones.

Therefore we put the \&{Outputs\_of\_a\_pattern} into a \&{set} and we store
iterators to the \&{set} as the trie outputs. The \&{set} iterators are
guaranteed not to change when \&{set} operations are performed. (Of course
the iterator becomes invalid if you delete a \&{set} member it points to,
but nobody makes us do it.)

If the number of different outputs is supposed to be high we should not
use this and we would better make the previously defined objects as
outputs of the pattern manipulator.

Here we inherit the \&{set}. We also need the empty member to be present
all the time. Therefore we provide the \\{empty\_iter} value and in the
constructor we create the empty member. The \\{empty\_iter} value may be
used as ``no output is here'' special value for the pattern manipulator.
Of course, never remove the empty output field from the object.

Also printing statistics is here.

\Y\B\4\X43:Outputs of patterns (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tposition}${},\39{}$\&{class} %
\&{Toutput}${}\rangle{}$\6
\&{class} \&{Outputs\_of\_patterns} :\6
\&{public} ${}\&{std}\DC\&{set}\langle\&{Outputs\_of\_a\_pattern}\langle%
\&{Tposition},\39\&{Toutput}\rangle\rangle{}$\6
${}\{{}$\1\6
\4\&{private}:\6
${}\&{Outputs\_of\_patterns}\langle\&{Tposition},\39\&{Toutput}\rangle\DC%
\&{iterator}{}$ \\{empty\_iter};\7
\4\&{public}:\6
\&{Outputs\_of\_patterns}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tposition},\39\&{Toutput}\rangle{}$ %
\\{empty};\7
${}\\{empty\_iter}\K(\this\MG\\{insert}(\\{empty})).\\{first};{}$\6
\4${}\}{}$\2\7
${}\&{Outputs\_of\_patterns}\langle\&{Tposition},\39\&{Toutput}\rangle\DC%
\&{iterator}{}$ \\{get\_empty\_iter}(\&{void}) \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{empty\_iter};\6
\4${}\}{}$\2\7
\&{void} \\{print\_statistics}(\,) \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\.{"\ \ number\ of\ differe}\)\.{nt\ outputs:\ \ \ \ \ "}\LL%
\\{size}(\,)\LL\\{endl};{}$\6
\4${}\}{}$\2\2\6
${}\}{}$;\par
\U41.\fi

\N{1}{44}Multi-output pattern manipulator. This service provides a language
storage with handling of multiple outputs for a word. A word may have
outputs on different positions.

This is a composition of two objects, a pattern manipulator and an
output handling service.

Well, why don't we inherit the pattern manipulator and override only
things needed to different kind of output? It is a good question. The
conceptual problem is, whether the multi-output manipulator is a special
pattern manipulator, or if it has a pattern manipulator and an output
manipulator. Both the cases are acceptable, I think. I would also prefer
inheritance to composition in this case, but there is a problem.

If we inherited the pattern manipulator, we must call it's constructor
and tell it the parameter \\{out\_inf\_zero}. Therefore we need to construct
the
outputs of patterns manipulator first. But we can't as the order of
constructing subobject is strict. We would have to inherit the output
manipulator first, which is conceptually absolutely stupid as the
multi-output manipulator is not an output manipulator.

It also brings more writing for me as public procedures of the pattern
manipulator must have their interfaces here too. It's a real C++ puzzle.

\Y\B\F\\{Tindex} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Tout\_alph} \5
\\{int}\par
\Y\B\4\X44:Multi output pattern manipulator (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tout\_alph}${}\rangle{}$\6
\&{class} \&{Multi\_output\_pattern\_manipulator} ${}\{{}$\1\6
\X45:Multi output pattern manipulator: data\X\6
\X46:Multi output pattern manipulator: constructor and destructor\X\6
\X47:Multi output pattern manipulator: gets and sets\X\7
\X48:Multi output pattern manipulator: walking through\X\6
\X49:Multi output pattern manipulator: word output\X\6
\X50:Multi output pattern manipulator: word last output\X\6
\X51:Multi output pattern manipulator: insert pattern\X\6
\X52:Multi output pattern manipulator: delete values\X\6
\X53:Multi output pattern manipulator: delete position\X\6
\X54:Multi output pattern manipulator: delete pattern\X\6
\X55:Multi output pattern manipulator: delete hanging\X\6
\X56:Multi output pattern manipulator: print statistics\X\2\6
${}\}{}$;\par
\U41.\fi

\M{45}Data structures of multi-output pattern manipulator. We have a pattern
trie manipulator to hold input words and an output set to hold their
outputs. The pattern manipulator has iterators to the set as the output
information associated with a word.

\Y\B\4\X45:Multi output pattern manipulator: data\X${}\E{}$\6
\4\&{protected}:\6
\&{typedef} ${}\&{Outputs\_of\_patterns}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle\DC\&{iterator}{}$ \&{Tout\_iter};\6
${}\&{Outputs\_of\_patterns}\langle\&{Tindex},\39\&{Tout\_alph}\rangle{}$ %
\\{outputs};\6
${}\&{Trie\_pattern\_manipulator}\langle\&{Tindex},\39\&{Tin\_alph},\39\&{Tout%
\_iter}\rangle{}$ \\{words};\par
\U44.\fi

\M{46}In the constructor, we have to set initial values to the embedded
objects. The \\{words} manipulator is initialized with the \\{max\_in\_alph}
value and the empty set iterator as the ``zero output information.''
Once more: never remove the empty field from the \\{outputs} set, or
strange things will happen.

The other constructor copies the manipulator. The ``logical'' content of
the original (\\{old}) object is copied, so the copy may use less memory.
Nevertheless the copying process is quite time-consuming as it is linear
in number of all (position, value) pairs in the manipulator's language.
The \\{old} object is passed by value and cannot be \&{const} as the
walk-through procedure changes it's hidden data structures. But the
language of \\{old} is not changed.

This copying may be also used to decrease the number of unused outputs
of patterns as it is no other reasonable way to delete them, so we let
them rest in peace even if they are no longer used.

\Y\B\4\X46:Multi output pattern manipulator: constructor and destructor\X${}%
\E{}$\6
\4\&{public}:\6
\&{Multi\_output\_pattern\_manipulator}(\&{const} \&{Tin\_alph} ${}{\AND}\\{max%
\_i\_a}){}$\1\1\2\2\6
: \\{outputs}(\,)${},\39{}$ ${}\\{words}(\\{max\_i\_a},\39\\{outputs}.\\{get%
\_empty\_iter}(\,){}$)\6
${}\{\,\}{}$\7
\&{Multi\_output\_pattern\_manipulator}(\&{Multi\_output\_pattern\_manipulator}
${}{\AND}\\{old}){}$\1\1\2\2\6
: \\{outputs}(\,)${},\39{}$ ${}\\{words}(\\{old}.\\{get\_max\_in\_alph}(\,),\39%
\\{outputs}.\\{get\_empty\_iter}(\,){}$)\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \|w;\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}\rangle{}$ %
\|o;\7
${}\\{old}.\\{init\_walk\_through}(\,);{}$\6
\&{while} ${}(\\{old}.\\{get\_next\_pattern}(\|w,\39\|o)){}$\1\6
\&{for} ${}(\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle\DC\&{iterator}{}$ \|i${}\K\|o.\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(%
\,);{}$ ${}\|i\PP){}$\1\5
${}\this\MG\\{insert\_pattern}(\|w,\39\|i\MG\\{first},\39\|i\MG\\{second});{}$%
\2\2\6
\4${}\}{}$\2\7
\&{virtual} ${}\CM\&{Multi\_output\_pattern\_manipulator}(\,){}$\1\1\2\2\6
${}\{{}$\SHC{ nothing to do here }\6
\,${}\}{}$\par
\U44.\fi

\M{47}Several values may be public-available. Self-commenting, isn't it?

\Y\B\4\X47:Multi output pattern manipulator: gets and sets\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{Tindex} \\{get\_max\_in\_alph}(\&{void}) \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{words}${}.\\{get\_max\_in\_alph}(\,);{}$\6
\4${}\}{}$\2\7
\&{virtual} \&{Tindex} \\{get\_pat\_count}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{words}${}.\\{get\_pat\_count}(\,);{}$\6
\4${}\}{}$\2\par
\U44.\fi

\M{48}Walking through the manipulator language. First, call the
\\{init\_walk\_through} method and then you may \\{get\_next\_pattern}. The
\\{get\_next\_pattern} procedure returns patterns with their outputs one by
one. The return value is \\{true}. When no pattern remains, \\{false} is
returned and \|w is an empty vector, \|o is empty, too.

This process may be broken by deleting and inserting patterns. The
operation of changing outputs of an {\it existing\/} word is safe.

For full details, consult documentation of \\{get\_next\_pattern} method of
the parent class. And again (it starts to be boring): never forget to
call \\{init\_walk\_through} first.

\Y\B\4\X48:Multi output pattern manipulator: walking through\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{virtual} \&{void} \\{init\_walk\_through}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\\{words}.\\{init\_walk\_through}(\,);{}$\6
\4${}\}{}$\2\7
\&{virtual} \&{bool} ${}\\{get\_next\_pattern}(\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39%
\&{Tout\_alph}\rangle{}$ ${}{\AND}\|o){}$\1\1\2\2\6
${}\{{}$\1\6
\&{bool} \\{ret\_val};\6
${}\&{Outputs\_of\_patterns}\langle\&{Tindex},\39\&{Tout\_alph}\rangle\DC%
\&{iterator}{}$ \|i;\7
${}\\{ret\_val}\K\\{words}.\\{get\_next\_pattern}(\|w,\39\|i);{}$\6
${}\|o\K{*}\|i;{}$\6
\&{return} \\{ret\_val};\6
\4${}\}{}$\2\par
\U44.\fi

\M{49}If we want to know the output of a word, we fill a \&{multimap} with
(position, value) pairs. There may be more values per position, we
cannot choose the highest one as we do not know the order.

Note this is not the ``hyphenate'' procedure, this returns outputs of
all patterns matching the beginning of the \|w.

Well, how shall we do it? We get all outputs of the \|w from the \\{words}
manipulator. It is a \&{vector} of \&{set} \&{iterator}s. Dereferencing them,
we get \&{multimap}s having pairs (position, value). We collect them and put
them into the \&{multimap}.

FIXME: It would be nicer to use a bit more optimal structure than vector
when asking the \\{words} for outputs. There is a lot of \\{out\_inf\_zero}
paddings.

\Y\B\4\X49:Multi output pattern manipulator: word output\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{word\_output}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}\rangle{}$
${}{\AND}\|w,\39\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle{}$ ${}{\AND}\|o){}$\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tout\_iter}\rangle{}$ \\{out\_pointers};\SHC{ iterators
to outputs }\7
${}\\{words}.\\{word\_output}(\|w,\39\\{out\_pointers});{}$\6
${}\|o.\\{clear}(\,){}$;\SHC{ no outputs }\6
\&{for} ${}(\&{vector}\langle\&{Tout\_iter}\rangle\DC\&{const\_iterator}{}$ %
\|i${}\K\\{out\_pointers}.\\{begin}(\,);{}$ ${}\|i\I\\{out\_pointers}.\\{end}(%
\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\SHC{ go through all outputs }\1\6
\&{for} ${}(\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle\DC\&{const\_iterator}{}$ \|j${}\K({*}\|i)\MG\\{begin}(\,);{}$ ${}\|j%
\I({*}\|i)\MG\\{end}(\,);{}$ ${}\|j\PP){}$\5
${}\{{}$\SHC{ go through the map }\1\6
${}\|o.\\{insert}({*}\|j);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U44.\fi

\M{50}We may also want only the last output. We get output of the \|w from
the \\{words} manipulator. It is a \&{set} \&{iterator}. Dereferencing it, we
get a \&{multimap} having pairs (position, value). We put them into the
\&{multimap}.

\Y\B\4\X50:Multi output pattern manipulator: word last output\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{word\_last\_output}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39%
\&{Tout\_alph}\rangle{}$ ${}{\AND}\|o){}$\1\1\2\2\6
${}\{{}$\1\6
${}\&{Outputs\_of\_patterns}\langle\&{Tindex},\39\&{Tout\_alph}\rangle\DC%
\&{iterator}{}$ \|i;\7
${}\\{words}.\\{word\_last\_output}(\|w,\39\|i);{}$\6
${}\|o\K{*}\|i;{}$\6
\4${}\}{}$\2\par
\U44.\fi

\M{51}We insert patterns in this way. We find the previous output set of the
pattern, we copy the outputs, update them and insert into the set again.
We are not allowed to do it in-place as we cannot change outputs of
other patterns. The \|p parameter is word position associated with the
\|v value.

If the \\{with\_erase} is \\{true} the previous outputs are deleted. The value
defaults to \\{false}.

\Y\B\4\X51:Multi output pattern manipulator: insert pattern\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{insert\_pattern}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39{}$\&{const} \&{Tindex} ${}{\AND}\|p,\39{}$\&{const}
\&{Tout\_alph} ${}{\AND}\|v,\39{}$\&{bool} \\{with\_erase}${}\K\\{false}){}$\1%
\1\2\2\6
${}\{{}$\1\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}\rangle{}$ %
\|o;\7
${}\\{word\_last\_output}(\|w,\39\|o){}$;\SHC{ now we have the outputs of the
word }\6
\&{if} (\\{with\_erase})\1\5
${}\|o.\\{erase}(\|p);{}$\2\6
${}\|o.\\{insert}(\\{make\_pair}(\|p,\39\|v)){}$;\SHC{ we add the new output to
the copy and put it back }\6
${}\\{words}.\\{hard\_insert\_pattern}(\|w,\39\\{outputs}.\\{insert}(\|o).%
\\{first});{}$\6
\4${}\}{}$\2\par
\U44.\fi

\M{52}Deleting patterns may be done in several ways. Here all outputs with
given value \|v are removed. Nothing else is changed. (It is PATGENs
deleting bad patterns.)

We walk through all the words, all their outputs. We take a copy of the
output, delete unwanted values from there (by copying again) and put the
output back using the \\{hard\_insert\_pattern} method of \\{word}. This
overwrites
the outputs at once.

\Y\B\4\X52:Multi output pattern manipulator: delete values\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{delete\_values}(\&{const} \&{Tout\_alph} ${}{\AND}\|v){}$\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \|w;\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}\rangle{}$ %
\|o;\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}\rangle{}$ %
\|n;\7
\\{init\_walk\_through}(\,);\6
\&{while} ${}(\\{get\_next\_pattern}(\|w,\39\|o)){}$\5
${}\{{}$\1\6
${}\|n.\\{clear}(\,);{}$\6
\&{for} ${}(\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle\DC\&{iterator}{}$ \|i${}\K\|o.\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(%
\,);{}$ ${}\|i\PP){}$\1\6
\&{if} ${}(\|i\MG\\{second}\I\|v){}$\1\5
${}\|n.\\{insert}({*}\|i){}$;\SHC{ delete given output }\2\2\6
${}\\{words}.\\{hard\_insert\_pattern}(\|w,\39\\{outputs}.\\{insert}(\|n).%
\\{first}){}$;\SHC{ put it back }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U44.\fi

\M{53}We may also want to delete an output of a pattern on given position.
This deletes all the output(s) of word \|w on position \|p.

\Y\B\4\X53:Multi output pattern manipulator: delete position\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{delete\_position}(\&{const} ${}\&{vector}\langle\&{Tin\_alph}%
\rangle{}$ ${}{\AND}\|w,\39{}$\&{const} \&{Tindex} ${}{\AND}\|p){}$\1\1\2\2\6
${}\{{}$\1\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tin\_alph}\rangle{}$ \|o;%
\7
${}\\{word\_last\_output}(\|w,\39\|o){}$;\SHC{ outputs of a word }\6
${}\|o.\\{erase}(\|p){}$;\SHC{ erase all outputs with \|p as the index }\6
${}\\{words}.\\{hard\_insert\_pattern}(\|w,\39\\{outputs}.\\{insert}(\|o).%
\\{first}){}$;\SHC{ put it back }\6
\4${}\}{}$\2\par
\U44.\fi

\M{54}The \\{delete\_pattern} procedure removes all outputs of a word \|w.

\Y\B\4\X54:Multi output pattern manipulator: delete pattern\X${}\E{}$\6
\4\&{public}:\6
\&{void} ${}\\{delete\_pattern}(\&{vector}\langle\&{Tin\_alph}\rangle{}$ ${}{%
\AND}\|w){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{words}.\\{hard\_insert\_pattern}(\|w,\39\\{outputs}.\\{get\_empty\_iter}(%
\,));{}$\6
\4${}\}{}$\2\par
\U44.\fi

\M{55}The \\{delete\_hanging} procedure removes the unused manipulator fields
which have been left on their places after pattern deletions. This does
not change the manipulator language.

Now the procedure does not dispose the outputs. We assume that the
number of deleted outputs is much smaller to the number of outputs and
the deleting procedure would be quite expensive.

\Y\B\4\X55:Multi output pattern manipulator: delete hanging\X${}\E{}$\6
\4\&{public}:\6
\&{virtual} \&{void} \\{delete\_hanging}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\\{words}.\\{delete\_hanging}(\,);{}$\6
\4${}\}{}$\2\par
\U44.\fi

\M{56}Printing statistics (ehm, nothing to say here).

\Y\B\4\X56:Multi output pattern manipulator: print statistics\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{print\_statistics}(\&{void}) \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\\{words}.\\{print\_statistics}(\,);{}$\6
${}\\{outputs}.\\{print\_statistics}(\,);{}$\6
\4${}\}{}$\2\par
\U44.\fi

\N{1}{57}Competitive multi output pattern manipulator. The multi output
pattern manipulator does not know anything about the order of output
symbols. To make the pattern output handling easy and to avoid
unpleasant pattern output constructing in higher application levels, we
provide following object enlarging the capabilities of the manipulator.
The output information is a number (with standard order) in most cases,
so this will be usually more suitable solution for multi output pattern
handling.

Now we suppose the \&{Tout\_alph} to have the ``$<$'' operation defined.
The knowledge of order of the symbols lets us to make the
\\{competitive\_pattern\_output} routine with at most one output information
per position.

I personally prefer longer names, but overfull hboxes made me to use
such a terrible abbreviation for this class.

\Y\B\F\\{Tindex} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Tout\_alph} \5
\\{int}\par
\Y\B\4\X57:Competitive multi out pat manip (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tout\_alph}${}\rangle{}$\6
\&{class} \&{Competitive\_multi\_out\_pat\_manip} :\6
\&{public} ${}\&{Multi\_output\_pattern\_manipulator}\langle\&{Tindex},\39%
\&{Tin\_alph},\39\&{Tout\_alph}\rangle{}$ ${}\{{}$\1\6
\X58:Competitive multi out pat manip: constructor and destructor\X\6
\X59:Competitive multi out pat manip: competitive word output\X\6
\X60:Competitive multi out pat manip: competitive pattern output\X\2\6
${}\}{}$;\par
\U41.\fi

\M{58}Constructor and destructor have nothing interesting. They propagate
the values to their parents. Also the copy constructor may be used to
rebuild the data structures in more efficient way.

\Y\B\4\X58:Competitive multi out pat manip: constructor and destructor\X${}%
\E{}$\6
\4\&{public}:\6
\&{Competitive\_multi\_out\_pat\_manip}(\&{const} \&{Tin\_alph} ${}{\AND}\\{max%
\_i\_a}){}$\1\1\2\2\6
: ${}\&{Multi\_output\_pattern\_manipulator}\langle\&{Tindex},\39\&{Tin\_alph},%
\39\&{Tout\_alph}\rangle(\\{max\_i\_a}){}$ ${}\{\,\}{}$\7
\&{Competitive\_multi\_out\_pat\_manip}(\&{Competitive\_multi\_out\_pat\_manip}
${}{\AND}\\{old}){}$\1\1\2\2\6
: ${}\&{Multi\_output\_pattern\_manipulator}\langle\&{Tindex},\39\&{Tin\_alph},%
\39\&{Tout\_alph}\rangle(\\{old}){}$ ${}\{\,\}{}$\7
${}\CM\&{Competitive\_multi\_out\_pat\_manip}(\,){}$\1\1\2\2\6
${}\{{}$\SHC{ nothing to do here }\6
\,${}\}{}$\par
\U57.\fi

\M{59}We need to collect the intercharacter values in a bit different way,
we take the new one if and only if the new one wins over the old one.
Here we compute the word output \|o for the word \|w. Therefore we put
the shift \|s value so that the position information may be stored
according to the original word. Strictly speaking, all the positions in
the word outputs are increased with \|s, the values are not affected by
this process.

Note that this method does not delete the previously collected outputs,
only changes the ones on appropriate positions. Go on reading the next
method to understand what is this index mess good for.

Only values $<$\\{ignore\_bigger} are collected and taken into account.

\Y\B\4\X59:Competitive multi out pat manip: competitive word output\X${}\E{}$\6
\4\&{protected}:\6
\&{void} \\{competitive\_word\_output}(\&{const} ${}\&{vector}\langle\&{Tin%
\_alph}\rangle{}$ ${}{\AND}\|w,\39\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},%
\39\&{Tout\_alph}\rangle{}$ ${}{\AND}\|o,\39{}$\&{const} \&{Tindex} ${}{\AND}%
\|s,\39{}$\&{const} \&{Tout\_alph} ${}{\AND}\\{ignore\_bigger}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tout\_iter}\rangle{}$ \\{out\_pointers};\SHC{ iterators
to outputs }\6
${}\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}\rangle\DC%
\&{iterator}{}$ \\{oi};\7
${}\\{words}.\\{word\_output}(\|w,\39\\{out\_pointers});{}$\6
\&{for} ${}(\&{vector}\langle\&{Tout\_iter}\rangle\DC\&{const\_iterator}{}$ %
\|i${}\K\\{out\_pointers}.\\{begin}(\,);{}$ ${}\|i\I\\{out\_pointers}.\\{end}(%
\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\SHC{ go through all outputs }\1\6
\&{for} ${}(\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},\39\&{Tout\_alph}%
\rangle\DC\&{const\_iterator}{}$ \|j${}\K({*}\|i)\MG\\{begin}(\,);{}$ ${}\|j%
\I({*}\|i)\MG\\{end}(\,);{}$ ${}\|j\PP){}$\5
${}\{{}$\SHC{ go through the map }\1\6
\&{if} ${}(\|j\MG\\{second}\G\\{ignore\_bigger}){}$\1\5
\&{continue};\SHC{ value to ignore }\2\6
${}\\{oi}\K\|o.\\{find}(\|s+(\|j\MG\\{first})){}$;\SHC{ find that position }\6
\&{if} ${}(\\{oi}\E\|o.\\{end}(\,){}$)\SHC{ has not been there before }\1\6
${}\|o.\\{insert}(\\{make\_pair}(\|s+(\|j\MG\\{first}),\39\|j\MG%
\\{second}));{}$\2\6
\&{else}\5
${}\{{}$\SHC{ has been there }\1\6
\&{if} ${}(\\{oi}\MG\\{second}<\|j\MG\\{second}){}$\5
${}\{{}$\SHC{ we'll help }\1\6
${}\|o.\\{erase}(\|s+(\|j\MG\\{first}));{}$\6
${}\|o.\\{insert}(\\{make\_pair}(\|s+(\|j\MG\\{first}),\39\|j\MG%
\\{second}));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U57.\fi

\M{60}This procedure computes all outputs \|o of all patterns matching the
word \|w. The output contains at most one value per position, if there
were more values per position, the maximum is output.

We go through all the postfixes of the word and collect (in the
competitive sense) all the outputs using the previous routine. Only
values $<$\\{ignore\_bigger} are collected. It means if a smaller value
should be overridden by value $\ge$\\{ignore\_bigger}, the original value
is left. If all outputs are needed, suply the \\{ignore\_bigger} value with
something bigger than anything in the manipulator.

\Y\B\4\X60:Competitive multi out pat manip: competitive pattern output\X${}%
\E{}$\6
\4\&{public}:\6
\&{void} \\{competitive\_pattern\_output}(\&{const} ${}\&{vector}\langle\&{Tin%
\_alph}\rangle{}$ ${}{\AND}\|w,\39\&{Outputs\_of\_a\_pattern}\langle\&{Tindex},%
\39\&{Tout\_alph}\rangle{}$ ${}{\AND}\|o,\39{}$\&{const} \&{Tout\_alph} ${}{%
\AND}\\{ignore\_bigger}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\|o.\\{clear}(\,);{}$\7
\&{Tindex} \|s${}\K\T{0}{}$;\SHC{ shift for the whole word }\7
\&{for} ${}(\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{const\_iterator}{}$ %
\|i${}\K\|w.\\{begin}(\,);{}$ ${}\|i\I\|w.\\{end}(\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\SHC{ for all postfixes }\1\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ ${}\|v(\|i,\39\|w.\\{end}(\,)){}$;%
\SHC{ take the postfix }\7
${}\\{competitive\_word\_output}(\|v,\39\|o,\39\|s,\39\\{ignore\_bigger});{}$\6
${}\|s\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U57.\fi

\N{1}{61}Simple translation service. This service is meant usually for testing
purposes.

\Y\B\4\X61:\.{ptl\_sts.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_STS\_H}\6
\8\#\&{define} \.{PTL\_STS\_H}\6
\8\#\&{include} \.{<map>}\6
\8\#\&{include} \.{<set>}\6
\X62:Simple translation service (head)\X\6
\8\#\&{endif}\par
\fi

\M{62}Simple translation service. We map the application used values into
unsigned numbers for the purpose of manipulating patterns. Therefore we
provide the translation service. The service is initialized with a set
of external symbols and it builds a bijection from the set into the
numbers $1,\ldots,n$, where $n$ is the number of symbols used.

The bijection is internally stored as array of external type values and
as \&{map} for the inverse. The mapping into external value is computed in
constant time, the inversion is computed in at most logarithmic time to
the number of used symbols. Note that this time may be optimized if we
know the external type.

The \&{Texternal} is type of external values, this type must be able to be
\&{map}ped.

\Y\B\F\\{Texternal} \5
\\{int}\par
\Y\B\4\X62:Simple translation service (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Texternal}${}\rangle{}$\6
\&{class} \&{Simple\_translation\_service} ${}\{{}$\1\6
\4\&{public}:\6
\&{typedef} \&{unsigned} \&{Tinternal};\6
\4\&{protected}:\6
\&{Texternal} ${}{*}\\{to\_external};{}$\6
${}\&{map}\langle\&{Texternal},\39\&{Tinternal}\rangle{}$ \\{to\_internal};\6
\&{Tinternal} \\{last\_used\_internal};\7
\X63:Simple translation service: constructor and destructor\X\6
\X64:Simple translation service: gets and sets\X\6
\X65:Simple translation service: internal\X\6
\X66:Simple translation service: external\X\2\6
${}\}{}$;\par
\U61.\fi

\M{63}The constructor of \&{Simple\_translation\_service} builds up the
translation and the inverse translation tables. The parameter is a \&{set}
of external values.

The destructor cleans up used storage.

\Y\B\4\X63:Simple translation service: constructor and destructor\X${}\E{}$\6
\4\&{public}:\6
\&{Simple\_translation\_service}(\&{const} ${}\&{set}\langle\&{Texternal}%
\rangle{}$ ${}{\AND}\\{ext\_set}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{to\_internal}.\\{clear}(\,);{}$\6
${}\\{last\_used\_internal}\K\T{0};{}$\6
${}\\{to\_external}\K{}$\&{new} \&{Texternal}${}[\\{ext\_set}.\\{size}(\,)+%
\T{1}];{}$\6
\&{for} ${}(\&{set}\langle\&{Texternal}\rangle\DC\&{const\_iterator}{}$ \|i${}%
\K\\{ext\_set}.\\{begin}(\,);{}$ ${}\|i\I\\{ext\_set}.\\{end}(\,);{}$ ${}\|i%
\PP){}$\5
${}\{{}$\1\6
${}\\{last\_used\_internal}\PP;{}$\6
${}\\{to\_external}[\\{last\_used\_internal}]\K{*}\|i;{}$\6
${}\\{to\_internal}.\\{insert}(\\{make\_pair}({*}\|i,\39\\{last\_used%
\_internal}));{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
\&{virtual} ${}\CM\&{Simple\_translation\_service}(\,){}$\1\1\2\2\6
${}\{{}$\1\6
\&{delete}[\,] \\{to\_external};\6
\4${}\}{}$\2\par
\U62.\fi

\M{64}The user may want to know the last used internal code.

\Y\B\4\X64:Simple translation service: gets and sets\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{virtual} \&{Tinternal} \\{get\_last\_used\_internal}(\&{void}) %
\&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{last\_used\_internal};\6
\4${}\}{}$\2\par
\U62.\fi

\M{65}The \\{internal} function returns internal code of external value. Note
that no range checks are done for the reason of speed. This function is
nevertheless logarithmic to the number of internal values used so we do
not want to slow it down more.

The second function is overloaded for handling vectors.

\Y\B\4\X65:Simple translation service: internal\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{virtual} \&{Tinternal} \\{internal}(\&{const} \&{Texternal} ${}{%
\AND}\|e){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\&{map}\langle\&{Texternal},\39\&{Tinternal}\rangle\DC\&{const\_iterator}{}$
\\{it}${}\K\\{to\_internal}.\\{find}(\|e);{}$\7
\&{return} ${}({*}\\{it}).\\{second};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{virtual} ${}\&{vector}\langle\&{Tinternal}\rangle{}$ %
\\{internal}(\&{const} ${}\&{vector}\langle\&{Texternal}\rangle{}$ ${}{\AND}%
\\{ve}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tinternal}\rangle{}$ \\{vi};\7
\&{for} ${}(\&{vector}\langle\&{Texternal}\rangle\DC\&{const\_iterator}{}$ %
\|i${}\K\\{ve}.\\{begin}(\,);{}$ ${}\|i\I\\{ve}.\\{end}(\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{vi}.\\{push\_back}(\\{internal}({*}\|i));{}$\6
\4${}\}{}$\2\6
\&{return} \\{vi};\6
\4${}\}{}$\2\par
\U62.\fi

\M{66}This function returns external values for internal ones. It may be
used for single values or for vectors. No range checks are performed for
efficiency reasons.

\Y\B\4\X66:Simple translation service: external\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{virtual} \&{Texternal} \\{external}(\&{const} \&{Tinternal} ${}{%
\AND}\|i){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{to\_external}[\|i];\6
\4${}\}{}$\2\7
\&{inline} \&{virtual} ${}\&{vector}\langle\&{Texternal}\rangle{}$ %
\\{external}(\&{const} ${}\&{vector}\langle\&{Tinternal}\rangle{}$ ${}{\AND}%
\\{vi}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Texternal}\rangle{}$ \\{ve};\7
\&{for} ${}(\&{vector}\langle\&{Tinternal}\rangle\DC\&{const\_iterator}{}$ %
\|i${}\K\\{vi}.\\{begin}(\,);{}$ ${}\|i\I\\{vi}.\\{end}(\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{ve}.\\{push\_back}(\\{external}({*}\|i));{}$\6
\4${}\}{}$\2\6
\&{return} \\{ve};\6
\4${}\}{}$\2\par
\U62.\fi

\N{0}{67}The generator companion.
The generator suite fixes the pattern generating strategy, nevertheless
most of the code may be reused in many cases. Terminological note: we speak
about ``hyphenation'', ``hyphenating points'' and so on. We are convinced
this makes the code easier to read, although the better terms would speak
about ``points of interest'' we want to find in our data. This would be
quite hard to type and hard to say, we think. Moreover it sounds terribly.

\fi

\M{68}We start with the Hyphenable word, \&{Hword} in short. We think about it
as
a fill-in form containing the input word in the beginning together with its
hyphenation information (information on correct points of interest, if
gentle reader wants to) which is later filled with the results of pattern
application on the word. The odd hyphenation values allow hyphenation, the
even values disallow.

\fi

\M{69}The patterns are generated in series of passes through the input file. In
each pass, we deal with pattern candidates of certain length and certain
hyphen position. We collect statistics for that type of patterns taking
into account the effect of patterns collected in previous passes. At the
end of a pass the candidates are checked and new patterns are added to the
pattern set.
The \\{left\_hyphen\_min} and \\{right\_hyphen\_min} values say the left and
right
border of a word where hyphenating is ignored.

Pattern candidates are selected one level at a time, in order of increasing
hyphenating value. Pattern candidates at each level are chosen in order of
increasing pattern length. Candidates at each level applying to different
intersymbol positions are chosen in separate passes through the input data
file. The selection of patterns out of candidates is controlled by the
\\{good\_wt}, \\{bad\_wt}, and \\{thresh} parameters. A pattern is selected if
$\\{good}*\\{good\_wt}-\\{bad}*\\{bad\_wt}\G\\{thresh}$, where \\{good} and %
\\{bad} are the
numbers of times the pattern is/is not good at the particular point. For
inhibiting levels, \\{good} is the number of errors inhibited, and \\{bad}
is the number of previously found (good) hyphens inhibited.

\fi

\M{70}The generator consists of three parts: the Pass, the Level and the
Generator. The Pass is the basic unit of the pattern generating process. It
reads the list of input words and chooses the candidate patterns with
certain length and dot position. At the end of a pass the candidates are
collected, it means the good ones are inserted into the pattern structure,
the bad ones are inserted too, but with special ``hyphenation
information'', to make them affect the following passes of that level and
to be able to delete them later.

The Level generates passes for the current level. It reads the pattern
length range and for all the pattern lengths and all dot positions there
creates a Pass. At the end of a Level the bad patterns are deleted.

The Generator creates Levels. It reads the level range and for all the
levels creates a Level. Before beginning the generating process the list of
patterns may be read in. It makes step-wise generating of the levels
possible, as the runs are quite time-consuming. In the end of the
generating process the input word list may be hyphenated with the set of
the patterns just created. It allows the user to see the work of them.

\fi

\M{71}Now we must say something about the input and output. The generator reads
input data file (Word input file), writes hyphenated word list (Word output
file), reads patterns (Pattern input file), and writes patterns (Pattern
output file). All the services use the Translate. The Translate reads the
translate file which is used to define input transformation on input file
and the alphabet. The Translate is constructed with a file name of the
translate file. The files get the reference to the Translate and the file
name to be constructed. The interface between the Translate and the file
object is their internal problem, the parts of the generator never touch
the Translate. The only exception is that Translate must provide methods
\\{get\_max\_in\_alph}, \\{get\_right\_hyphen\_min}, and \\{get\_left\_hyphen%
\_min}. The
values obtained are needed to construct the pattern storage. The origin of
that solution comes from OPATGEN, where the values depend on settings in
the translate file. The input files must provide the \&{bool} \\{get}(%
\&{THword} ${}{\AND}\|w)$
operation returning \\{true} if the \&{Hword} has been successfully read and
\\{false} at the end of the file. The output files must provide the
\\{put}(\&{THword} ${}{\AND}\|w)$ operation to write the \&{Hword} into the
file.

\fi

\N{1}{72}Hword. The \&{Hword} (as hyphenated/hyphenable word) is a sequence
of characters together with the hyphenation information. Let us define
the special information.

\Y\B\4\X72:\.{ptl\_hwrd.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_HWRD\_H}\6
\8\#\&{define} \.{PTL\_HWRD\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<vector>}\6
\8\#\&{include} \.{"ptl\_ga.h"}\6
\X73:Hword (head)\X\6
\8\#\&{endif}\par
\fi

\M{73}The first thing we want to know is the type of the hyphen point. The
values in \&{Thyf\_type} mean (in order of appearance) no hyphen is here,
this is an erroneous hyphen, this is a correct one and this is the
correct one but found sometimes in the past. Those values are defined as
a part of this object to ensure consistency.

The \&{Hword} itself is a collection of the sequence of characters and the
hyphenation information. The hyphenation information is stored in the
following public-accessible growing arrays:

\item{$\bullet$} \\{dots} is the hyphen type
\item{$\bullet$} \\{dotw} is the dot weight of \&{Twt\_type}
\item{$\bullet$} \\{hval} is the hyphenation value (simply the level
number) of \&{Tval\_type}
\item{$\bullet$} \\{no\_more} is the flag indicating the ``knocked-out''
position

The remaining template types are the word alphabet (\&{Tin\_alph}) and the
\&{Tindex} type for indexing the growing arrays (\&{unsigned} seems to be a
good choice).

Please follow the convention that the values applying between the
characters \\{word}[\|i] and $\\{word}[\|i+\T{1}]$ is stored in \\{dots}[\|i], %
\\{dotw}[\|i]
and so on. The fields are indexed from zero, except the word itself, which
is indexed from one. This makes storing information about the position left
to the leftmost words character possible.

\Y\B\F\\{Hword} \5
\\{int}\par
\B\F\\{Tindex} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Twt\_type} \5
\\{int}\par
\B\F\\{Tval\_type} \5
\\{int}\par
\B\F\\{Thyf\_type} \5
\\{int}\par
\Y\B\4\X73:Hword (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Twt\_type}${},\39{}$\&{class} \&{Tval\_type}${}%
\rangle{}$\6
\&{class} \&{Hword} :\6
\&{public} ${}\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle{}$ ${}\{{}$\1\6
\4\&{public}:\6
\&{typedef} \&{enum} ${}\{{}$\1\6
${}\\{no\_hyf},\39\\{err\_hyf},\39\\{is\_hyf},\39\\{found\_hyf}{}$\2\6
${}\}{}$ \&{Thyf\_type};\7
${}\&{Growing\_array}\langle\&{Tindex},\39\&{Thyf\_type}\rangle{}$ \\{dots};\6
${}\&{Growing\_array}\langle\&{Tindex},\39\&{Twt\_type}\rangle{}$ \\{dotw};\6
${}\&{Growing\_array}\langle\&{Tindex},\39\&{Tval\_type}\rangle{}$ \\{hval};\6
${}\&{Growing\_array}\langle\&{Tindex},\39\&{char}\rangle{}$ \\{no\_more};\7
\X74:Hword: constructors\X\6
\X76:Hword: clear\X\6
\X75:Hword: operator[\,]\X\6
\8\#\&{ifdef} \.{DEBUG}\6
\X77:Hword: print\X\SHC{Test code! }\6
\8\#\&{endif}\2\6
${}\}{}$;\par
\U72.\fi

\M{74}In the constructor we set up the values for embedded objects. The
constructor of the word is called and the default values to return when
accessing previously unacessed field of the arrays are set as follows.
The \\{dots} defaults to \\{no\_hyf}, the \\{dotw} should be usually 1 and the
\\{hval} should be zero. The positions are not knocked out, so \\{false}.

Nevertheless we provide the constructor with parameters, where the user
may set the default values.

\Y\B\4\X74:Hword: constructors\X${}\E{}$\6
\&{Hword}(\,)\1\1\2\2\6
: ${}\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle(\,),{}$\6
\\{dots}(\\{no\_hyf})${},\39{}$ \\{dotw}(\T{1})${},\39{}$ \\{hval}(\T{0})${},%
\39{}$ \\{no\_more}(\\{false}) ${}\{\,\}{}$\7
\&{Hword}(\&{const} \&{Thyf\_type} ${}{\AND}\|s,\39{}$\&{const} \&{Twt\_type}
${}{\AND}\|w,\39{}$\&{const} \&{Tval\_type} ${}{\AND}\|l,\39{}$\&{const} %
\&{char} ${}{\AND}\|e){}$\1\1\2\2\6
: ${}\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle(\,),{}$\6
\\{dots}(\|s)${},\39{}$ \\{dotw}(\|w)${},\39{}$ \\{hval}(\|l)${},\39{}$ \\{no%
\_more}(\|e) ${}\{\,\}{}$\par
\U73.\fi

\M{75}Operator [\,]. We want the \&{Hword} to be indexed from~1.

\Y\B\4\X75:Hword: operator[\,]\X${}\E{}$\6
\4\&{public}:\6
\&{inline} \&{Tin\_alph} ${}{\AND}{}$\&{operator}[\,](\&{const} \&{Tindex} ${}{%
\AND}\|i){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{operator}[%
\,](\|i-\T{1});{}$\6
\4${}\}{}$\2\par
\U73.\fi

\M{76}If the \&{Hword} is cleared, we must also clear the associated
information.

\Y\B\4\X76:Hword: clear\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{clear}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle\DC\\{clear}(\,){}$;\SHC{
clear the word itself }\6
${}\\{dots}.\\{clear}(\,);{}$\6
${}\\{dotw}.\\{clear}(\,);{}$\6
${}\\{hval}.\\{clear}(\,);{}$\6
${}\\{no\_more}.\\{clear}(\,);{}$\6
\4${}\}{}$\2\par
\U73.\fi

\M{77}Testing code---writing the word content.

\Y\B\4\X77:Hword: print\X${}\E{}$\6
\&{void} \\{print}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\.{"Hword"};{}$\6
\&{for} ${}(\&{std}\DC\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{iterator}{}$ %
\|i${}\K\this\MG\\{begin}(\,);{}$ ${}\|i\I\this\MG\\{end}(\,);{}$ ${}\|i\PP){}$%
\1\5
${}\\{cout}\LL\.{"\ "}\LL{*}\|i;{}$\2\6
${}\\{cout}\LL\\{endl}\LL\.{"dots"};{}$\6
\&{for} (\&{Tindex} \|i${}\K\T{0};{}$ ${}\|i\Z\this\MG\\{size}(\,);{}$ ${}\|i%
\PP){}$\1\5
${}\\{cout}\LL\.{"\ "}\LL\\{dots}[\|i];{}$\2\6
${}\\{cout}\LL\\{endl}\LL\.{"dotw"};{}$\6
\&{for} (\&{Tindex} \|i${}\K\T{0};{}$ ${}\|i\Z\this\MG\\{size}(\,);{}$ ${}\|i%
\PP){}$\1\5
${}\\{cout}\LL\.{"\ "}\LL\\{dotw}[\|i];{}$\2\6
${}\\{cout}\LL\\{endl}\LL\.{"hval"};{}$\6
\&{for} (\&{Tindex} \|i${}\K\T{0};{}$ ${}\|i\Z\this\MG\\{size}(\,);{}$ ${}\|i%
\PP){}$\1\5
${}\\{cout}\LL\.{"\ "}\LL\\{hval}[\|i];{}$\2\6
${}\\{cout}\LL\\{endl}\LL\.{"no\_m"};{}$\6
\&{for} (\&{Tindex} \|i${}\K\T{0};{}$ ${}\|i\Z\this\MG\\{size}(\,);{}$ ${}\|i%
\PP){}$\1\6
\&{if} (\\{no\_more}[\|i])\1\5
${}\\{cout}\LL\.{"\ t"};{}$\2\6
\&{else}\1\5
${}\\{cout}\LL\.{"\ f"};{}$\2\2\6
${}\\{cout}\LL\\{endl};{}$\6
\4${}\}{}$\2\par
\U73.\fi

\N{1}{78}The generator companion.
The generating process is described above. Here we talk
about the types in the templates of the generator companion. Note that not
all the objects (Generator, Level, and Pass) must take all the types. But
most of the types bubble down to the whole structure, therefore we consider
commenting them at one place more then suitable. (Moreover we must tell
cweave that all the ugly names are types.)

The \&{Tindex} is the type used to index the fields in the words and outputs.
The \&{Tin\_alph} is the input alphabet (preferably numerical).

The \&{Tval\_type} is the level number, this is the type of output of the
pattern.

The \&{Twt\_type} is the weight in the word, the hyphen position (or the whole
word) may have a weight which makes the position (all the positions of the
word) counted as more occurrences of the hyphenation point. Non-negative
number.

The \&{Tcount\_type} is the count of the times the position works OK/wrong in
the candidate taking process, non-negative number, note should be big
enough.

The \&{THword} is the Hyphenable word. More precisely said, this is an
object with the same interface as the \\{HWord} presented above. It should
also behave similarly :-). The same note applies to the following types
too.

The \&{TTranslate} is application dependent translate, may be also a fake
object (doing nothing) in case it's not needed. The object is defined in
the application, see the OPATGEN source for an example.

The \&{TCandidate\_count\_structure} is the object to store candidates related
to certain hyphenation level, pattern length and dot position. In our case
it stores the pairs of good/bad counts of \&{Tcount\_type}.

The \&{TCompetitive\_multi\_out\_pat\_manip} is the pattern store.

The \&{TOutputs\_of\_a\_pattern} is the output of the word from the previous
type.

The \&{TWord\_input\_file} and \&{TWord\_output\_file} for words are
application
dependent interfaces to the files. They use the \&{TTranslate} to handle
``file alphabet'' to internal alphabet translations.

The \&{TPattern\_input\_file} and \&{TPattern\_output\_file} are analogous
interfaces for pattern files.

The \&{TPass} is the type of the Pass generated by the Level.

The \&{TLevel} is the type of the Level generated by the Generator.

The ``overtemplatization'' may seem funny at first sight, but note that
quite global and big changes may be done by inheriting and changing the
template parameter. If another order of dot position selecting is needed,
you may inherit the Level, change one of its methods and change one of the
template parameters. If you want to change (for example) the pattern
selecting rule, there is nothing easier then to inherit the Pass and to
change the \\{collect\_candidates} method. (Well, there is something easier:
to prove the collecting is good enough for you:-).)

\Y\B\F\\{Tindex} \5
\\{int}\par
\B\F\\{Tin\_alph} \5
\\{int}\par
\B\F\\{Tval\_type} \5
\\{int}\par
\B\F\\{Twt\_type} \5
\\{int}\par
\B\F\\{Tcount\_type} \5
\\{int}\par
\B\F\\{THword} \5
\\{int}\par
\B\F\\{TTranslate} \5
\\{int}\par
\B\F\\{TCandidate\_count\_structure} \5
\\{int}\par
\B\F\\{TCompetitive\_multi\_out\_pat\_manip} \5
\\{int}\par
\B\F\\{TOutputs\_of\_a\_pattern} \5
\\{int}\par
\B\F\\{TWord\_input\_file} \5
\\{int}\par
\B\F\\{TWord\_output\_file} \5
\\{int}\par
\B\F\\{TPattern\_input\_file} \5
\\{int}\par
\B\F\\{TPattern\_output\_file} \5
\\{int}\par
\B\F\\{TPass} \5
\\{int}\par
\B\F\\{TLevel} \5
\\{int}\par
\fi

\M{79}All the objects of the generator come to one header.

\Y\B\4\X79:\.{ptl\_gen.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PTL\_GEN\_H}\6
\8\#\&{define} \.{PTL\_GEN\_H}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<cstdio>}\6
\8\#\&{include} \.{<iomanip>}\6
\8\#\&{include} \.{"ptl\_exc.h"}\6
\8\#\&{include} \.{"ptl\_mopm.h"}\6
\8\#\&{include} \.{"ptl\_hwrd.h"}\6
\X80:Pass (head)\X\6
\X91:Level (head)\X\6
\X95:Generator (head)\X\6
\8\#\&{endif}\par
\fi

\N{1}{80}Pass. The pass is the basic unit of pattern generating process.
We go through the input data and collect candidates of one length and
one hyphenating position. After that we choose good candidates and make
them patterns.

\Y\B\4\X80:Pass (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tval\_type}${},\39{}$\&{class} \&{Twt\_type}${},%
\39{}$\&{class} \&{Tcount\_type}${},\39{}$\&{class} \&{THword}${},\39{}$%
\&{class} \&{TTranslate}${},\39{}$\&{class} \&{TCandidate\_count%
\_structure}${},\39{}$\&{class} \&{TCompetitive\_multi\_out\_pat\_manip}${},%
\39{}$\&{class} \&{TOutputs\_of\_a\_pattern}${},\39{}$\&{class} \&{TWord\_input%
\_file}${}\rangle{}$\6
\&{class} \&{Pass} ${}\{{}$\1\6
\X81:Pass: data\X\6
\X82:Pass: constructor and destructor\X\7
\X83:Pass: hyphenate\X\6
\X84:Pass: change dots\X\6
\X85:Pass: do word\X\6
\X87:Pass: print pass statistics\X\6
\X88:Pass: do dictionary\X\6
\X89:Pass: collect candidates\X\6
\X90:Pass: do all\X\2\6
${}\}{}$;\par
\U79.\fi

\M{81}A number (mess, if you want to) of values follows.

\Y\B\4\X81:Pass: data\X${}\E{}$\6
\4\&{protected}:\6
\&{TTranslate} ${}{\AND}\\{translate}{}$;\SHC{ the translate service }\6
\&{const} \&{Tval\_type} \\{hyph\_level};\SHC{ current hyphenating symbol }\6
\&{const} \&{Tval\_type} \\{hopeless\_hyph\_val};\SHC{ fake number for bad
patterns }\6
\&{const} \&{Tindex} \\{left\_hyphen\_min};\SHC{ ignore leftmost part of words
}\6
\&{const} \&{Tindex} \\{right\_hyphen\_min};\SHC{ the same for right }\6
\&{const} \&{Tindex} \\{pat\_len};\SHC{ length of candidates we're dealing with
}\6
\&{const} \&{Tindex} \\{pat\_dot};\SHC{ current position }\6
\&{const} \&{Tcount\_type} \\{good\_wt}${},{}$ \\{bad\_wt}${},{}$ \\{thresh};%
\SHC{ pattern choosing weights }\6
\&{TCompetitive\_multi\_out\_pat\_manip} ${}{\AND}\\{patterns}{}$;\SHC{
patterns }\7
\&{Tcount\_type} \\{good\_count}${},{}$ \\{bad\_count}${},{}$ \\{miss\_count};%
\SHC{ statistics, hyphen counts }\6
\&{TCandidate\_count\_structure} \\{candidates};\SHC{ candidates we collect }\7
\&{TWord\_input\_file} \\{word\_input};\SHC{ the file we read }\7
\&{Tindex} \\{hyf\_min}${},{}$ \\{hyf\_max}${},{}$ \\{hyf\_len};\SHC{ see
constructor for explanation }\6
\&{Tindex} \\{dot\_min}${},{}$ \\{dot\_max}${},{}$ \\{dot\_len};\SHC{ see
constructor for explanation }\6
\&{typename} \&{THword}\DC\&{Thyf\_type} \\{good\_dot}${},{}$ \\{bad\_dot};%
\SHC{ see constructor for explanation }\par
\U80.\fi

\M{82}We simply set up the values. Moreover---to avoid unnecessary
tests---the variables \\{hyf\_min}, \\{hyf\_max}, and \\{hyf\_len} are set up
such that only positions from \\{hyf\_min} up to word length minus
\\{hyf\_max} of the word need to be checked. The words with length
$<$\\{hyf\_len} need not be checked at all.

The \\{dot\_min}, \\{dot\_max}, and \\{dot\_len} values are analogous and they
mean limits of legal dots.

The \\{good\_dot} and \\{bad\_dot} values depend on hyphenation level and are
used in \\{do\_word} routine.

\Y\B\4\X82:Pass: constructor and destructor\X${}\E{}$\6
\4\&{public}:\6
\&{Pass}(\&{TTranslate} ${}{\AND}\\{tra},\39{}$\&{const} \&{char} ${}{*}\\{i\_d%
\_f\_n},{}$\6
\&{const} \&{Tval\_type} ${}{\AND}\|l,\39{}$\&{const} \&{Tval\_type} ${}{\AND}%
\|h,{}$\6
\&{const} \&{Tindex} ${}{\AND}\\{lhm},\39{}$\&{const} \&{Tindex} ${}{\AND}%
\\{rhm},{}$\6
\&{const} \&{Tindex} ${}{\AND}\\{p\_l},\39{}$\&{const} \&{Tindex} ${}{\AND}\\{p%
\_d},{}$\6
\&{const} \&{Twt\_type} ${}{\AND}\\{g\_w},\39{}$\&{const} \&{Twt\_type} ${}{%
\AND}\\{b\_w},\39{}$\&{const} \&{Twt\_type} ${}{\AND}\|t,{}$\6
\&{TCompetitive\_multi\_out\_pat\_manip} ${}{\AND}\\{pat}){}$\1\1\2\2\6
: \\{translate}(\\{tra})${},{}$\6
\\{hyph\_level}(\|l)${},\39{}$ \\{hopeless\_hyph\_val}(\|h)${},{}$\6
\\{left\_hyphen\_min}(\\{lhm})${},\39{}$ \\{right\_hyphen\_min}(\\{rhm})${},{}$%
\6
\\{pat\_len}(\\{p\_l})${},\39{}$ \\{pat\_dot}(\\{p\_d})${},{}$\6
\\{good\_wt}(\\{g\_w})${},\39{}$ \\{bad\_wt}(\\{b\_w})${},\39{}$ \\{thresh}(%
\|t)${},{}$\6
\\{patterns}(\\{pat})${},{}$\7
\\{good\_count}(\T{0})${},\39{}$ \\{bad\_count}(\T{0})${},\39{}$ \\{miss%
\_count}(\T{0})${},{}$\6
${}\\{candidates}(\\{patterns}.\\{get\_max\_in\_alph}(\,),\39\T{0},\39%
\T{0}),{}$\6
${}\\{word\_input}(\\{translate},\39\\{i\_d\_f\_n}){}$ ${}\{{}$\1\6
${}\\{hyf\_min}\K\\{left\_hyphen\_min}+\T{1};{}$\6
${}\\{hyf\_max}\K\\{right\_hyphen\_min}+\T{1};{}$\6
${}\\{hyf\_len}\K\\{hyf\_min}+\\{hyf\_max}{}$;\7
${}\\{dot\_min}\K\\{pat\_dot};{}$\6
${}\\{dot\_max}\K\\{pat\_len}-\\{pat\_dot};{}$\6
\&{if} ${}(\\{dot\_min}<\\{hyf\_min}){}$\1\5
${}\\{dot\_min}\K\\{hyf\_min};{}$\2\6
\&{if} ${}(\\{dot\_max}<\\{hyf\_max}){}$\1\5
${}\\{dot\_max}\K\\{hyf\_max};{}$\2\6
${}\\{dot\_len}\K\\{dot\_min}+\\{dot\_max}{}$;\7
\&{if} ${}(\\{hyph\_level}\MOD\T{2}\E\T{1}){}$\5
${}\{{}$\1\6
${}\\{good\_dot}\K\&{THword}\DC\\{is\_hyf};{}$\6
${}\\{bad\_dot}\K\&{THword}\DC\\{no\_hyf};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{good\_dot}\K\&{THword}\DC\\{err\_hyf};{}$\6
${}\\{bad\_dot}\K\&{THword}\DC\\{found\_hyf};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{83}This procedure uses current patterns to hyphenate a word. The
hyphenation value applying between the characters \\{word}[\|i] and
$\\{word}[\|i+\T{1}]$ is stored in \\{hval}[\|i]. The bad patterns at this
level are
ignored.

Moreover, \\{no\_more}[\|i] is set to \\{true} iff the position is ``knocked
out'' by either good or bad pattern at this level. It means, the pattern
with current length and hyphen position is superstring of a pattern at
this level. In that case we don't have to collect count statistics for
that pattern as it can't be chosen in this pass. In addition, there is no
need to insert that pattern into the count repository. Note that we have
to hyphenate again to get the bad patterns of this level into account.

\Y\B\4\X83:Pass: hyphenate\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{hyphenate}(\&{THword} ${}{\AND}\|w){}$\1\1\2\2\6
${}\{{}$\1\6
\&{TOutputs\_of\_a\_pattern} \|o;\6
\&{typename} \&{TOutputs\_of\_a\_pattern}\DC\&{iterator} \|i;\7
${}\\{patterns}.\\{competitive\_pattern\_output}(\|w,\39\|o,\39\\{hopeless%
\_hyph\_val});{}$\6
\&{for} ${}(\|i\K\|o.\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(\,);{}$ ${}\|i%
\PP){}$\5
${}\{{}$\SHC{ go through the output }\1\6
${}\|w.\\{hval}[\|i\MG\\{first}]\K\|i\MG\\{second}{}$;\SHC{ copy it into \|w }\6
\4${}\}{}$\2\6
${}\\{patterns}.\\{competitive\_pattern\_output}(\|w,\39\|o,\39\\{hopeless%
\_hyph\_val}+\T{1}){}$;\SHC{ now compute the output including the bad values }\6
\&{for} ${}(\|i\K\|o.\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(\,);{}$ ${}\|i%
\PP){}$\5
${}\{{}$\SHC{ go through the output }\1\6
\&{if} ${}(\|i\MG\\{second}\G\\{hyph\_level}\W\|i\MG\\{first}\G\\{dot\_min}\W%
\|i\MG\\{first}\Z\|w.\\{size}(\,)-\\{dot\_max}){}$\5
${}\{{}$\1\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \\{subw};\7
\&{for} (\&{Tindex} \|j${}\K\|i\MG\\{first}+\T{1}-\\{pat\_dot};{}$ ${}\|j\Z\|i%
\MG\\{first}+\\{pat\_len}-\\{pat\_dot};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
${}\\{subw}.\\{push\_back}(\|w[\|j]);{}$\6
\4${}\}{}$\2\7
\&{TOutputs\_of\_a\_pattern} \\{subwo};\7
${}\\{patterns}.\\{competitive\_pattern\_output}(\\{subw},\39\\{subwo},\39%
\\{hopeless\_hyph\_val}+\T{1});{}$\7
\&{typename} \&{TOutputs\_of\_a\_pattern}\DC\&{iterator} \\{val\_on\_pat%
\_dot}${}\K\\{subwo}.\\{find}(\\{pat\_dot}){}$;\C{ The value has been obtained
by competitive outputting, it means there          is at most one value on each
position. }\7
\&{if} ${}(\\{val\_on\_pat\_dot}\I\\{subwo}.\\{end}(\,)){}$\1\6
\&{if} ${}(\\{val\_on\_pat\_dot}\MG\\{second}\G\\{hyph\_level}){}$\1\5
${}\|w.\\{no\_more}[\|i\MG\\{first}]\K\\{true};{}$\2\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{84}The \\{change\_dots} procedure updates the meaning of hyphen values.
Initially the hyphens in the word list are represented by \\{is\_hyf} and
non-hyphen positions by \\{no\_hyf}.

Now we change this values according to the hyphens found by current
patterns. So we change \\{no\_hyf} into \\{err\_hyf} and \\{is\_hyf} into
\\{found\_hyf}.

Moreover we collect statistics about the number of good, bad and missed
hyphens.

\Y\B\4\X84:Pass: change dots\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{change\_dots}(\&{THword} ${}{\AND}\|w){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for} (\&{Tindex} \|i${}\K\|w.\\{size}(\,)-\\{hyf\_max};{}$ ${}\|i\G\\{hyf%
\_min};{}$ ${}\|i\MM){}$\5
${}\{{}$\1\6
\&{if} ${}(\|w.\\{hval}[\|i]\MOD\T{2}\E\T{1}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|w.\\{dots}[\|i]\E\&{THword}\DC\\{no\_hyf}){}$\1\5
${}\|w.\\{dots}[\|i]\K\&{THword}\DC\\{err\_hyf};{}$\2\6
\&{else} \&{if} ${}(\|w.\\{dots}[\|i]\E\&{THword}\DC\\{is\_hyf}){}$\1\5
${}\|w.\\{dots}[\|i]\K\&{THword}\DC\\{found\_hyf};{}$\2\6
\4${}\}{}$\2\7
\&{if} ${}(\|w.\\{dots}[\|i]\E\&{THword}\DC\\{found\_hyf}){}$\1\5
${}\\{good\_count}\MRL{+{\K}}\|w.\\{dotw}[\|i];{}$\2\6
\&{else} \&{if} ${}(\|w.\\{dots}[\|i]\E\&{THword}\DC\\{err\_hyf}){}$\1\5
${}\\{bad\_count}\MRL{+{\K}}\|w.\\{dotw}[\|i];{}$\2\6
\&{else} \&{if} ${}(\|w.\\{dots}[\|i]\E\&{THword}\DC\\{is\_hyf}){}$\1\5
${}\\{miss\_count}\MRL{+{\K}}\|w.\\{dotw}[\|i];{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{85}For each dot position of current word, we first check if we need to
consider it. It might be knocked out or we don't care about. For
example, when considering hyphenating patterns, there's no need to
count hyphens already found.

If a relevant dot is found, we increment the counts in the candidate
store (which inserts first if necessary).

(Why does cweave think \\{fpos} is a type? We must tell explicitly it is not.)
\Y\B\F\\{fpos} \5
\\{dpos}\par
\Y\B\4\X85:Pass: do word\X${}\E{}$\6
\4\&{protected}:\6
\&{void} \\{do\_word}(\&{THword} ${}{\AND}\|w){}$\1\1\2\2\6
${}\{{}$\1\6
\&{for} (\&{Tindex} \\{dpos}${}\K\|w.\\{size}(\,)-\\{dot\_max};{}$ ${}\\{dpos}%
\G\\{dot\_min};{}$ ${}\\{dpos}\MM){}$\5
${}\{{}$\1\6
\X86:Pass: (do word) check this dot position and \&{continue} if do not care\X\7
\&{Tindex} \\{spos}${}\K\\{dpos}-\\{pat\_dot}{}$;\SHC{ compute the subword
range }\6
\&{Tindex} \\{fpos}${}\K\\{spos}+\\{pat\_len};{}$\7
${}\\{spos}\PP;{}$\7
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \\{subw};\SHC{ compute the subword
}\7
\&{for} (\&{Tindex} \|i${}\K\\{spos};{}$ ${}\|i\Z\\{fpos};{}$ ${}\|i\PP){}$\1\5
${}\\{subw}.\\{push\_back}(\|w[\|i]);{}$\2\6
\&{if} ${}(\|w.\\{dots}[\\{dpos}]\E\\{good\_dot}){}$\5
${}\{{}$\1\6
${}\\{candidates}.\\{increment\_counts}(\\{subw},\39\|w.\\{dotw}[\\{dpos}],\39%
\T{0}){}$;\SHC{ good }\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{candidates}.\\{increment\_counts}(\\{subw},\39\T{0},\39\|w.\\{dotw}[%
\\{dpos}]){}$;\SHC{ bad }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{86}If the dot position is knocked out or a ``do not care'', we skip this
position.

\Y\B\4\X86:Pass: (do word) check this dot position and \&{continue} if do not
care\X${}\E{}$\6
\&{if} ${}(\|w.\\{no\_more}[\\{dpos}]){}$\1\5
\&{continue};\2\6
\&{if} ${}((\|w.\\{dots}[\\{dpos}]\I\\{good\_dot})\W(\|w.\\{dots}[\\{dpos}]\I%
\\{bad\_dot})){}$\1\5
\&{continue};\2\par
\U85.\fi

\M{87}Printing pass statistics.

\Y\B\4\X87:Pass: print pass statistics\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{print\_pass\_statistics}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\\{endl};{}$\6
${}\\{cout}\LL\\{good\_count}\LL\.{"\ good\ "}\LL\\{bad\_count}\LL\.{"\ bad\ "}%
\LL\\{miss\_count}\LL\.{"\ missed"}\LL\\{endl};{}$\6
\&{if} ${}(\\{good\_count}+\\{miss\_count}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{cout}\LL\T{100.0}*\\{good\_count}/\&{float}(\\{good\_count}+\\{miss%
\_count})\LL\.{"\ \%\ "};{}$\6
${}\\{cout}\LL\T{100.0}*\\{bad\_count}/\&{float}(\\{good\_count}+\\{miss%
\_count})\LL\.{"\ \%\ "};{}$\6
${}\\{cout}\LL\T{100.0}*\\{miss\_count}/\&{float}(\\{good\_count}+\\{miss%
\_count})\LL\.{"\ \%\ "}\LL\\{endl};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U80.\fi

\M{88}Go through the input file, process the words. At the end print the
pass statistics.

\Y\B\4\X88:Pass: do dictionary\X${}\E{}$\6
\4\&{protected}:\6
\&{void} \\{do\_dictionary}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{THword} \|w;\7
\&{while} ${}(\\{word\_input}.\\{get}(\|w)){}$\5
${}\{{}$\SHC{ process words until end of file }\1\6
\&{if} ${}(\|w.\\{size}(\,)\G\\{hyf\_len}){}$\5
${}\{{}$\SHC{ don't hyphenate short words }\1\6
\\{hyphenate}(\|w);\6
\\{change\_dots}(\|w);\6
\4${}\}{}$\2\6
\&{if} ${}(\|w.\\{size}(\,)\G\\{dot\_len}){}$\1\5
\\{do\_word}(\|w);\SHC{ process if reasonable }\2\6
\4${}\}{}$\2\7
\8\#\&{ifdef} \.{DEBUG}\SHC{ test code }\7
\&{TOutputs\_of\_a\_pattern} \|o;\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \\{word};\7
${}\\{patterns}.\\{init\_walk\_through}(\,);{}$\6
${}\\{cout}\LL\.{"Patterns\ in\ the\ pat}\)\.{tern\ manipulator:"}\LL%
\\{endl};{}$\6
\&{while} ${}(\\{patterns}.\\{get\_next\_pattern}(\\{word},\39\|o)){}$\5
${}\{{}$\1\6
${}\\{cout}\LL\.{"Word\ "};{}$\6
\&{for} ${}(\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{iterator}{}$ \|i${}\K%
\\{word}.\\{begin}(\,);{}$ ${}\|i\I\\{word}.\\{end}(\,);{}$ ${}\|i\PP){}$\1\5
${}\\{cout}\LL{*}\|i\LL\.{"\ "};{}$\2\6
${}\\{cout}\LL\.{"...\ has\ "};{}$\6
\&{for} (\&{typename} \&{TOutputs\_of\_a\_pattern}\DC\&{const\_iterator} \|i${}%
\K\|o.\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(\,);{}$ ${}\|i\PP){}$\1\5
${}\\{cout}\LL\.{"("}\LL\|i\MG\\{first}\LL\.{","}\LL\|i\MG\\{second}\LL\.{")\
"};{}$\2\6
${}\\{cout}\LL\\{endl};{}$\6
\4${}\}{}$\2\7
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \\{vect};\6
\&{Tcount\_type} \|a;\6
\&{Tcount\_type} \|b;\7
${}\\{candidates}.\\{init\_walk\_through}(\,);{}$\6
${}\\{cout}\LL\.{"Candidates:"}\LL\\{endl};{}$\6
\&{while} ${}(\\{candidates}.\\{get\_next\_pattern}(\\{vect},\39\|a,\39\|b)){}$%
\5
${}\{{}$\1\6
\&{for} ${}(\&{vector}\langle\&{Tin\_alph}\rangle\DC\&{iterator}{}$ \|i${}\K%
\\{vect}.\\{begin}(\,);{}$ ${}\|i\I\\{vect}.\\{end}(\,);{}$ ${}\|i\PP){}$\1\5
${}\\{cout}\LL{*}\|i\LL\.{"\ "};{}$\2\6
${}\\{cout}\LL\.{"with\ g,b:\ "}\LL\|a\LL\.{","}\LL\|b\LL\\{endl};{}$\6
\4${}\}{}$\SHC{ end of test code }\2\6
\8\#\&{endif}\6
\\{print\_pass\_statistics}(\,);\6
${}\\{cout}\LL\.{"Count\ data\ structur}\)\.{e\ statistics:"}\LL\\{endl};{}$\6
${}\\{candidates}.\\{print\_statistics}(\,);{}$\6
\4${}\}{}$\2\par
\U80.\fi

\M{89}At the end of a pass, we traverse the \\{candidates} selecting good and
bad patterns and inserting them into the \\{patterns} structure.

The \|g and \|b values of the \|w word contain the number of times this
pattern helps or hinders the cause. We here determine if the pattern
should be selected, or if it is hopeless, or if we cannot decide yet. In
the latter case, we return \\{more\_to\_come} value \\{true}.
This means there may still be good patterns extending current type of
patterns.
The \\{more\_to\_come} value is returned to the caller.
Before we finish this, we print some statistics to the user.

Also note that hopeless patterns are inserted into the \\{patterns}
structure with the fake hyphenation value, so as they will be able to be
deleted later.

\Y\B\4\X89:Pass: collect candidates\X${}\E{}$\6
\4\&{protected}:\6
\&{bool} \\{collect\_candidates}(\&{Tcount\_type} ${}{\AND}\\{level\_pattern%
\_count}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\.{"Collecting\ candidat}\)\.{es"}\LL\\{endl};{}$\7
\&{bool} \\{more\_to\_come}${}\K\\{false};{}$\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \|w;\SHC{ word }\6
\&{Tcount\_type} \|g${},{}$ \|b;\SHC{ good and bad from pattern }\6
\&{Tcount\_type} \\{good\_pat\_count}${}\K\T{0};{}$\6
\&{Tcount\_type} \\{bad\_pat\_count}${}\K\T{0}{}$;\SHC{ numbers of patterns
added at the end of a pass }\7
${}\\{candidates}.\\{init\_walk\_through}(\,);{}$\6
\&{while} ${}(\\{candidates}.\\{get\_next\_pattern}(\|w,\39\|g,\39\|b)){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{good\_wt}*\|g<\\{thresh}){}$\5
${}\{{}$\SHC{ hopeless pattern }\1\6
${}\\{patterns}.\\{insert\_pattern}(\|w,\39\\{pat\_dot},\39\\{hopeless\_hyph%
\_val});{}$\6
${}\\{bad\_pat\_count}\PP;{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\C{ now we test $\\{good\_wt}*\|g-\\{bad\_wt}*\|b\G\\{thresh}$ but we
may not          deal with negative numbers (it took me four hours to find) }\1%
\6
\&{if} ${}(\\{good\_wt}*\|g\G\\{thresh}+\\{bad\_wt}*\|b){}$\5
${}\{{}$\SHC{ good pattern }\1\6
${}\\{patterns}.\\{insert\_pattern}(\|w,\39\\{pat\_dot},\39\\{hyph\_level},\39%
\T{1}){}$;\SHC{ we may erase the previous outputs }\6
${}\\{good\_pat\_count}\PP;{}$\6
${}\\{good\_count}\MRL{+{\K}}\|g;{}$\6
${}\\{bad\_count}\MRL{+{\K}}\|b;{}$\6
\4${}\}{}$\2\6
\&{else}\1\5
${}\\{more\_to\_come}\K\\{true};{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\7
${}\\{cout}\LL\\{good\_pat\_count}\LL\.{"\ good\ and\ "}\LL\\{bad\_pat\_count}%
\LL\.{"\ bad\ patterns\ added}\)\.{"};{}$\6
\&{if} ${}(\\{more\_to\_come}\E\\{true}){}$\1\5
${}\\{cout}\LL\.{"\ (more\ to\ come)"};{}$\2\6
${}\\{cout}\LL\\{endl};{}$\6
${}\\{cout}\LL\.{"finding\ "}\LL\\{good\_count}\LL\.{"\ good\ and\ "}\LL\\{bad%
\_count}\LL\.{"\ bad\ hyphens"}\LL\\{endl};{}$\6
\&{if} ${}(\\{good\_pat\_count}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{cout}\LL\.{"efficiency\ =\ "}\LL\&{float}(\\{good\_count})/(\&{float}(%
\\{good\_pat\_count})+\&{float}(\\{bad\_count})/(\&{float}(\\{thresh})/%
\&{float}(\\{good\_wt})))\LL\\{endl};{}$\6
\4${}\}{}$\2\6
${}\\{cout}\LL\.{"Pattern\ data\ struct}\)\.{ure\ statistics:"}\LL\\{endl};{}$\6
${}\\{patterns}.\\{print\_statistics}(\,){}$;\7
${}\\{level\_pattern\_count}\MRL{+{\K}}\\{good\_pat\_count};{}$\6
\&{return} \\{more\_to\_come};\6
\4${}\}{}$\2\par
\U80.\fi

\M{90}Make the pass and return the \\{more\_to\_come} value.

\Y\B\4\X90:Pass: do all\X${}\E{}$\6
\4\&{public}:\6
\&{bool} \\{do\_all}(\&{Tcount\_type} ${}{\AND}\\{level\_pattern\_count}){}$\1%
\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\\{endl}\LL\.{"Generating\ a\ pass\ w}\)\.{ith\ pat\_len\ =\ "}%
\LL\\{pat\_len}\LL\.{",\ pat\_dot\ =\ "}\LL\\{pat\_dot}\LL\\{endl};{}$\6
\\{do\_dictionary}(\,);\6
\&{return} \\{collect\_candidates}(\\{level\_pattern\_count});\6
\4${}\}{}$\2\par
\U80.\fi

\N{1}{91}Level.
In the level, patterns with given hyphenating information on various
positions are collected. We read the parameters and generate passes.

\Y\B\4\X91:Level (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tval\_type}${},\39{}$\&{class} \&{Twt\_type}${},%
\39{}$\&{class} \&{Tcount\_type}${},\39{}$\&{class} \&{THword}${},\39{}$%
\&{class} \&{TTranslate}${},\39{}$\&{class} \&{TCandidate\_count%
\_structure}${},\39{}$\&{class} \&{TCompetitive\_multi\_out\_pat\_manip}${},%
\39{}$\&{class} \&{TWord\_input\_file}${},\39{}$\&{class} \&{TPass}${}%
\rangle{}$\6
\&{class} \&{Level} ${}\{{}$\1\6
\X92:Level: data\X\6
\X93:Level: constructor and destructor\X\6
\X94:Level: do all\X\2\6
${}\}{}$;\par
\U79.\fi

\M{92}We have to know the current hyphenation value \\{hyph\_level}, the
\\{hopeless\_hyph\_val} is a fake value used to determine bad patterns we
have to collect but we delete them later.

Left and right hyphen minimal positions are the bounds of the hyphen
positions measured from the beginning and end of a word where we ignore
hyphenating.

The \\{patterns} is the global
pattern storage. The \\{level\_pattern\_count} is used for statistics.

Variables \\{pat\_start} and \\{pat\_finish} are the minimal and maximal
lengths of pattern candidates in this level and \\{good\_wt}, \\{bad\_wt}, and
\\{thresh} are used for choosing patterns when collecting candidates.

\Y\B\4\X92:Level: data\X${}\E{}$\6
\4\&{protected}:\6
\&{TTranslate} ${}{\AND}\\{translate};{}$\6
\&{const} \&{char} ${}{*}\\{word\_input\_file\_name};{}$\6
\&{const} \&{Tval\_type} \\{hyph\_level};\6
\&{const} \&{Tval\_type} \\{hopeless\_hyph\_val};\6
\&{const} \&{Tindex} \\{left\_hyphen\_min}${},{}$ \\{right\_hyphen\_min};\6
\&{TCompetitive\_multi\_out\_pat\_manip} ${}{\AND}\\{patterns};{}$\6
\&{Tcount\_type} \\{level\_pattern\_count};\6
\&{Tindex} \\{pat\_start}${},{}$ \\{pat\_finish};\6
\&{Tcount\_type} \\{good\_wt}${},{}$ \\{bad\_wt}${},{}$ \\{thresh};\par
\U91.\fi

\M{93}We read the values of the pattern length range and the parameters for
choosing candidates. Of course we initialize the default values.

\Y\B\4\X93:Level: constructor and destructor\X${}\E{}$\6
\4\&{public}:\6
\&{Level}(\&{TTranslate} ${}{\AND}\\{tra},\39{}$\&{const} \&{char} ${}{*}\\{i%
\_d\_f\_n},\39{}$\&{const} \&{Tval\_type} ${}{\AND}\|l,\39{}$\&{const} \&{Tval%
\_type} ${}{\AND}\|h,\39{}$\&{const} \&{Tindex} ${}{\AND}\\{lhm},\39{}$%
\&{const} \&{Tindex} ${}{\AND}\\{rhm},\39{}$\&{TCompetitive\_multi\_out\_pat%
\_manip} ${}{\AND}\|p){}$\1\1\2\2\6
: \\{translate}(\\{tra})${},\39{}$ \\{word\_input\_file\_name}(\\{i\_d\_f%
\_n})${},\39{}$ \\{hyph\_level}(\|l)${},\39{}$ \\{hopeless\_hyph\_val}(\|h)${},%
\39{}$ \\{left\_hyphen\_min}(\\{lhm})${},\39{}$ \\{right\_hyphen\_min}(%
\\{rhm})${},\39{}$ \\{patterns}(\|p)${},\39{}$ \\{level\_pattern\_count}(\T{0})
${}\{{}$\1\6
\&{do}\5
${}\{{}$\SHC{ read the pattern length range }\1\6
${}\\{cout}\LL\.{"pat\_start,\ pat\_fini}\)\.{sh:\ "};{}$\6
${}\\{cin}\GG\\{pat\_start};{}$\6
${}\\{cin}\GG\\{pat\_finish};{}$\6
\&{if} ${}(\\{pat\_start}<\T{1}\V\\{pat\_start}>\\{pat\_finish}){}$\5
${}\{{}$\1\6
${}\\{cout}\LL\.{"Specify\ two\ integer}\)\.{s\ satisfying\ 1<=pat\_}\)%
\.{start<=pat\_finish\ "};{}$\6
${}\\{pat\_start}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\\{pat\_start}<\T{1}){}$;\7
\&{do}\5
${}\{{}$\SHC{ read the weights }\1\6
${}\\{cout}\LL\.{"good\ weight,\ bad\ we}\)\.{ight,\ threshold:\ "};{}$\6
${}\\{cin}\GG\\{good\_wt};{}$\6
${}\\{cin}\GG\\{bad\_wt};{}$\6
${}\\{cin}\GG\\{thresh};{}$\6
\&{if} ${}(\\{good\_wt}<\T{1}\V\\{bad\_wt}<\T{1}\V\\{thresh}<\T{1}){}$\5
${}\{{}$\1\6
${}\\{cout}\LL\.{"Specify\ three\ integ}\)\.{ers:\ good\ weight,\ ba}\)\.{d\
weight,\ threshold>}\)\.{=1\ "};{}$\6
${}\\{good\_wt}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\\{good\_wt}<\T{1});{}$\6
\4${}\}{}$\2\par
\U91.\fi

\M{94}In a given level, the patterns of given length are generated with dot
positions in an ``organ-pipe'' fashion. For example, for $\\{pat\_len}\E\T{4}$
we choose patterns for different positions in the order 2, 1, 3, 0, 4.
For all positions passes are generated.

The array \\{more\_this\_level} remembers which positions are permanently
``knocked out'', this is, if there are no possible good patterns at that
dot position, we do not have to consider longer patterns at this level
containing that position.

At the end of a level the bad patterns are deleted.

\Y\B\4\X94:Level: do all\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{do\_all}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\\{cout}\LL\\{endl}\LL\\{endl}\LL\.{"Generating\ level\ "}\LL\\{hyph\_level}%
\LL\\{endl};{}$\7
${}\&{Growing\_array}\langle\&{Tindex},\39\&{char}\rangle{}$ \\{more\_this%
\_level}(\\{true});\7
\&{for} (\&{Tindex} \\{pat\_len}${}\K\\{pat\_start};{}$ ${}\\{pat\_len}\Z\\{pat%
\_finish};{}$ ${}\\{pat\_len}\PP){}$\5
${}\{{}$\SHC{ for all pattern lengths }\1\6
\&{Tindex} \\{pat\_dot}${}\K\\{pat\_len}/\T{2};{}$\6
\&{Tindex} \\{dot1}${}\K\\{pat\_dot}*\T{2};{}$\7
\&{do}\5
${}\{{}$\SHC{ for all positions }\1\6
${}\\{pat\_dot}\K\\{dot1}-\\{pat\_dot};{}$\6
${}\\{dot1}\K\\{pat\_len}*\T{2}-\\{dot1}-\T{1};{}$\6
\&{if} (\\{more\_this\_level}[\\{pat\_dot}])\5
${}\{{}$\SHC{ which are not knocked out }\1\6
\&{TPass} ${}\\{pass}(\\{translate},\39\\{word\_input\_file\_name},\39\\{hyph%
\_level},\39\\{hopeless\_hyph\_val},\39\\{left\_hyphen\_min},\39\\{right%
\_hyphen\_min},\39\\{pat\_len},\39\\{pat\_dot},\39\\{good\_wt},\39\\{bad\_wt},%
\39\\{thresh},\39\\{patterns});{}$\7
${}\\{more\_this\_level}[\\{pat\_dot}]\K\\{pass}.\\{do\_all}(\\{level\_pattern%
\_count});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\\{pat\_dot}\I\\{pat\_len}){}$;\7
\&{for} (\&{Tindex} \|k${}\K\\{more\_this\_level}.\\{size}(\,);{}$ ${}\|k\G%
\T{1};{}$ ${}\|k\MM){}$\1\6
\&{if} ${}(\\{more\_this\_level}[\|k-\T{1}]\I\\{true}){}$\1\5
${}\\{more\_this\_level}[\|k]\K\\{false};{}$\2\2\6
\4${}\}{}$\SHC{ OK, we have generated }\2\7
\&{Tindex} \\{old\_p\_c}${}\K\\{patterns}.\\{get\_pat\_count}(\,);{}$\7
${}\\{patterns}.\\{delete\_values}(\\{hopeless\_hyph\_val}){}$;\SHC{ now delete
bad patterns }\6
${}\\{cout}\LL\\{old\_p\_c}-\\{patterns}.\\{get\_pat\_count}(\,)\LL\.{"\ bad\
patterns\ delet}\)\.{ed"}\LL\\{endl};{}$\6
${}\\{patterns}.\\{delete\_hanging}(\,){}$;\7
${}\\{cout}\LL\.{"total\ of\ "}\LL\\{level\_pattern\_count}\LL\.{"\ patterns\
at\ level\ }\)\.{"}\LL\\{hyph\_level}\LL\\{endl};{}$\6
\4${}\}{}$\2\par
\U91.\fi

\N{1}{95}Generator. This is where we start the real work. We read the values of
\\{hyph\_start} and \\{hyph\_finish}, create the set of needed symbols,
create the pattern store and generate levels.

\Y\B\4\X95:Generator (head)\X${}\E{}$\6
$\&{template}\langle{}$\&{class} \&{Tindex}${},\39{}$\&{class} \&{Tin%
\_alph}${},\39{}$\&{class} \&{Tval\_type}${},\39{}$\&{class} \&{Twt\_type}${},%
\39{}$\&{class} \&{Tcount\_type}${},\39{}$\&{class} \&{THword}${},\39{}$%
\&{class} \&{TTranslate}${},\39{}$\&{class} \&{TCandidate\_count%
\_structure}${},\39{}$\&{class} \&{TCompetitive\_multi\_out\_pat\_manip}${},%
\39{}$\&{class} \&{TOutputs\_of\_a\_pattern}${},\39{}$\&{class} \&{TWord\_input%
\_file}${},\39{}$\&{class} \&{TWord\_output\_file}${},\39{}$\&{class} %
\&{TPattern\_input\_file}${},\39{}$\&{class} \&{TPattern\_output\_file}${},%
\39{}$\&{class} \&{TPass}${},\39{}$\&{class} \&{TLevel}${}\rangle{}$\6
\&{class} \&{Generator} ${}\{{}$\1\6
\X96:Generator: data\X\6
\X97:Generator: constructor\X\6
\X98:Generator: read patterns\X\6
\X99:Generator: output patterns\X\6
\X100:Generator: hyphenate word list\X\6
\X101:Generator: do all\X\2\6
${}\}{}$;\par
\U79.\fi

\M{96}The generator needs to know the hyphenation level range, multiple output
pattern store, and values \\{left\_hyphen\_min} and \\{right\_hyphen\_min}
telling the bounds where hyphenation should be ignored.

\Y\B\4\X96:Generator: data\X${}\E{}$\6
\4\&{protected}:\6
\&{TTranslate} \\{translate};\6
\&{const} \&{char} ${}{*}\\{name};{}$\6
\&{const} \&{char} ${}{*}\\{word\_input\_file\_name};{}$\6
\&{const} \&{char} ${}{*}\\{pattern\_input\_file\_name};{}$\6
\&{const} \&{char} ${}{*}\\{pattern\_output\_file\_name};{}$\6
\&{TCompetitive\_multi\_out\_pat\_manip} \\{patterns};\6
\&{Tval\_type} \\{hyph\_start}${},{}$ \\{hyph\_finish};\6
\&{Tindex} \\{left\_hyphen\_min}${},{}$ \\{right\_hyphen\_min};\par
\U95.\fi

\M{97}In the constructor we create the translate service, pattern structure,
set the values, and read the hyphenation level range.

\Y\B\4\X97:Generator: constructor\X${}\E{}$\6
\4\&{public}:\6
\&{Generator}(\&{const} \&{char} ${}{*}\\{dic},\39{}$\&{const} \&{char} ${}{*}%
\\{pat},\39{}$\&{const} \&{char} ${}{*}\\{out},\39{}$\&{const} \&{char} ${}{*}%
\\{tra}){}$\1\1\2\2\6
: \\{translate}(\\{tra})${},\39{}$ \\{word\_input\_file\_name}(\\{dic})${},%
\39{}$ \\{pattern\_input\_file\_name}(\\{pat})${},\39{}$ \\{pattern\_output%
\_file\_name}(\\{out})${},\39{}$ ${}\\{patterns}(\\{translate}.\\{get\_max\_in%
\_alph}(\,)),\39{}$ ${}\\{left\_hyphen\_min}(\\{translate}.\\{get\_left\_hyphen%
\_min}(\,)),\39{}$ ${}\\{right\_hyphen\_min}(\\{translate}.\\{get\_right%
\_hyphen\_min}(\,)){}$ ${}\{{}$\1\6
\&{do}\5
${}\{{}$\SHC{ read the level range }\1\6
${}\\{cout}\LL\.{"hyph\_start,\ hyph\_fi}\)\.{nish:\ "};{}$\6
${}\\{cin}\GG\\{hyph\_start};{}$\6
${}\\{cin}\GG\\{hyph\_finish};{}$\6
\&{if} ${}((\\{hyph\_start}<\T{1})\V(\\{hyph\_finish}<\T{1})){}$\5
${}\{{}$\1\6
${}\\{hyph\_start}\K\T{0};{}$\6
${}\\{cout}\LL\.{"Specify\ two\ integer}\)\.{s\ satisfying\ 1<=hyph}\)\.{%
\_start,\ hyph\_finish\ }\)\.{"}\LL\\{endl};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\\{hyph\_start}<\T{1});{}$\6
\4${}\}{}$\2\par
\U95.\fi

\M{98}Before starting a run, set of patterns may be read in.

\Y\B\4\X98:Generator: read patterns\X${}\E{}$\6
\&{void} \\{read\_patterns}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \|v;\6
\&{TOutputs\_of\_a\_pattern} \|o;\6
\&{TPattern\_input\_file} ${}\\{file}(\\{translate},\39\\{pattern\_input\_file%
\_name}){}$;\C{ open the
            file }\7
\&{while} ${}(\\{file}.\\{get}(\|v,\39\|o)){}$\5
${}\{{}$\SHC{ read the file }\1\6
\&{if} ${}(\|v.\\{size}(\,)>\T{0}){}$\5
${}\{{}$\SHC{ avoid strange things }\1\6
\&{for} (\&{typename} \&{TOutputs\_of\_a\_pattern}\DC\&{iterator} \|i${}\K\|o.%
\\{begin}(\,);{}$ ${}\|i\I\|o.\\{end}(\,);{}$ ${}\|i\PP){}$\5
${}\{{}$\SHC{ go through the outputs }\1\6
\&{if} ${}(\|i\MG\\{second}\G\\{hyph\_start}){}$\5
${}\{{}$\1\6
\&{throw} \&{Patlib\_error}(\.{"!\ The\ patterns\ to\ b}\)\.{e\ read\ in\
contain\ "}\6
\.{"hyphenation\ value\ b}\)\.{igger\ than\ hyph\_star}\)\.{t."});\6
\4${}\}{}$\2\6
${}\\{patterns}.\\{insert\_pattern}(\|v,\39\|i\MG\\{first},\39\|i\MG%
\\{second});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U95.\fi

\M{99}At the very end of work we output the patterns.

\Y\B\4\X99:Generator: output patterns\X${}\E{}$\6
\&{void} \\{output\_patterns}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{TPattern\_output\_file} ${}\\{file}(\\{translate},\39\\{pattern\_output%
\_file\_name});{}$\6
${}\&{vector}\langle\&{Tin\_alph}\rangle{}$ \|v;\6
\&{TOutputs\_of\_a\_pattern} \|o;\7
${}\\{patterns}.\\{init\_walk\_through}(\,);{}$\6
\&{while} ${}(\\{patterns}.\\{get\_next\_pattern}(\|v,\39\|o)){}$\5
${}\{{}$\1\6
${}\\{file}.\\{put}(\|v,\39\|o);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U95.\fi

\M{100}At the very end of a pass the word list may be hyphenated with the
patterns just made. So we prepare the input and output file. The pass we
use to hyphenate must have \\{left\_hyphen\_min} and \\{right\_hyphen\_min} set
to correct values.

The only problem is with the level number. Think about a special kind of
usage to hyphenate a word list with a set of patterns. This can be
simulated setting the level range like 6,~1, causing the levels itselves to
be skipped. Therefore we take normally as the level number the last level
we did. In the special case where the \\{hyph\_finish} is less than
\\{hyph\_start} we increase the value to the bigger one. (This feature has
been added for Petr Sojka.)

The rest of values is clean or makes no
effect to the \\{hyphenate} and \\{change\_dots} process. In the end, the
statistics of hyphens found, wrong, and missed is printed.
The output file is named ``pattmp.n'', where ``n'' is the last level
number. If bigger than 999, sorry MS~DOS users :-).

\Y\B\4\X100:Generator: hyphenate word list\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{hyphenate\_word\_list}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{string} \|s;\7
${}\\{cout}\LL\.{"hyphenate\ word\ list}\)\.{\ <y/n>?\ "};{}$\6
${}\\{cin}\GG\|s;{}$\6
\&{if} ${}(\R(\|s\E\.{"y"}\V\|s\E\.{"Y"})){}$\1\5
\&{return};\2\7
\&{Tval\_type} \\{level\_value}${}\K\\{hyph\_finish};{}$\7
\&{if} ${}(\\{hyph\_start}>\\{hyph\_finish}){}$\1\5
${}\\{level\_value}\K\\{hyph\_start};{}$\2\7
\&{Tval\_type} \\{fake\_level\_value}${}\K\T{2}*((\\{level\_value}/\T{2})+%
\T{1});{}$\6
\&{char} \\{file\_name}[\T{100}];\SHC{ Is there a less stupid way to do this? }%
\7
${}\\{sprintf}(\\{file\_name},\39\.{"pattmp.\%d"},\39\\{level\_value});{}$\6
${}\\{cout}\LL\.{"Writing\ file\ "}\LL\\{file\_name}\LL\\{endl};{}$\7
\&{THword} \|w;\6
\&{TWord\_output\_file} ${}\\{o\_f}(\\{translate},\39\\{file\_name});{}$\6
\&{TWord\_input\_file} ${}\\{i\_f}(\\{translate},\39\\{word\_input\_file%
\_name});{}$\6
\&{TPass} ${}\\{pass}(\\{translate},\39\\{word\_input\_file\_name},\39\\{level%
\_value},\39\\{fake\_level\_value},\39\\{left\_hyphen\_min},\39\\{right\_hyphen%
\_min},\39\T{1},\39\T{1},\39\T{1},\39\T{1},\39\T{1},\39\\{patterns});{}$\7
\&{while} ${}(\\{i\_f}.\\{get}(\|w)){}$\5
${}\{{}$\SHC{ go through the file }\1\6
\&{if} ${}(\|w.\\{size}(\,)>\T{2}){}$\5
${}\{{}$\1\6
${}\\{pass}.\\{hyphenate}(\|w);{}$\6
${}\\{pass}.\\{change\_dots}(\|w);{}$\6
\4${}\}{}$\2\6
${}\\{o\_f}.\\{put}(\|w);{}$\6
\4${}\}{}$\2\6
${}\\{pass}.\\{print\_pass\_statistics}(\,);{}$\6
\4${}\}{}$\2\par
\U95.\fi

\M{101}The \\{hopeless\_fake\_number} is a value which is even and greater than
any
hyphenating value used. So we compute it and create levels. In the end
the outputs are output and the word list is hyphenated.

\Y\B\4\X101:Generator: do all\X${}\E{}$\6
\4\&{public}:\6
\&{void} \\{do\_all}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\\{read\_patterns}(\,);\SHC{ read in patterns }\6
${}\\{cout}\LL\\{patterns}.\\{get\_pat\_count}(\,)\LL\.{"\ pattern\ lines\
read}\)\.{\ in"}\LL\\{endl};{}$\7
\&{Tval\_type} \\{hopeless\_fake\_number}${}\K\T{2}*((\\{hyph\_finish}/\T{2})+%
\T{1}){}$;\7
\&{for} (\&{Tval\_type} \|l${}\K\\{hyph\_start};{}$ ${}\|l\Z\\{hyph%
\_finish};{}$ ${}\|l\PP){}$\5
${}\{{}$\1\6
\&{TLevel} ${}\\{level}(\\{translate},\39\\{word\_input\_file\_name},\39\|l,\39%
\\{hopeless\_fake\_number},\39\\{left\_hyphen\_min},\39\\{right\_hyphen\_min},%
\39\\{patterns});{}$\7
${}\\{level}.\\{do\_all}(\,);{}$\6
\4${}\}{}$\2\6
\\{output\_patterns}(\,);\6
\\{hyphenate\_word\_list}(\,);\6
${}\\{cout}\LL\\{endl};{}$\6
\4${}\}{}$\2\par

\U95.\fi


\inx
\fin
\con
