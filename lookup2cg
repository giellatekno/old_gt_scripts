#!/usr/bin/perl
use strict;

# lookup2cg
# Perl-script for converting lookup-output to CG-2 input.
# - Rates and removes compound analyses according to 
#   the number of word boundaries.
# - Reformats compound analyses and base forms, removes duplicates
#
# Input: 
# Dan     dat+Pron+Dem+Sg+Acc
# Dan     dat+Pron+Dem+Sg+Gen
#
# Output:
# "<Dan>"
#        "dat" Pron Dem Sg Acc
#        "dat" Pron Dem Sg Gen
#
# $Id$

my @Analyses;
my %forms;
my %rated;
my $word;
my $tmp;
my $compound = 0;
my $comp_rate = 0;
my $max_comp_rate = 0;

$/ = "";

# Read while not eol
while(<>) {	

	my @Analyses;
	my %forms;
	my %rated;
	
	my $word;
	my $tmp;
	my $compound = 0;
	my $comp_rate = 0;
	my $max_comp_rate = 0;

	my @lines = split(/\n/, $_);
	for my $line (@lines) {
		# store word to a scalar and
		# analysis (=base form and tags) to an array
		my $analysis;
		($word, $analysis) = split(/\t/, $line, 2);
		$analysis =~ tr/\t//d;
		push @Analyses, $analysis;
		$comp_rate = tr/\#//;
		if ($comp_rate > $max_comp_rate) { 
			$max_comp_rate = $comp_rate; 
		}
	}
	# format the output and print
	if ($max_comp_rate > 0) { 
		while (@Analyses) {
			my $line = pop @Analyses;
			$rated{$line} = 1;
		}
		pop @Analyses;
		rate_compounds(\%rated); 
		for my $key (keys %rated) {
			push @Analyses, $key;
		}
	}
	# Format each analysis
	for my $line (@Analyses) {
		# Separate the base form from the analysis
		my ($base, $line2) = split(/\+/, $line, 2);
		$line2 =~ tr/+/ /;
		
		# If line contains a compound
		if ( $max_comp_rate > 0 ) {
			format_compound(\$base, \$line2, \$word); 
		}
		# Mark derivational tags
		1 while $line2 =~ s/\b(V|N|Adv|A)(\ |\ .*?\ )(V|N|Adv|A)\b/$1\*$2$3/g;
            
            #Format output
            $line =  "\t" . " \"$base\" " . $line2 . "\n";
 			
			# Store the analysis to a hash
			$forms{$line} = 1;
        }
		
		# Print output
        if (@Analyses) {
		print "\"<$word>\"\n";
		for my $line (keys %forms)
		{ print "$line"; }
		}
	} # end of while


sub rate_compounds {
	my $href = shift @_;
	
	# Rate compounds and remove extra readings.
	my $min_boundary_count=5;
	my $boundary_count=0;
	for (keys %$href) {
		$boundary_count = tr/\#//;
		if ( $boundary_count < $min_boundary_count )
		{ $min_boundary_count = $boundary_count; }
	}
	my $i=0;
	$boundary_count = 0;
	for (keys %$href) {
		$boundary_count = tr/\#//;
		if ( $boundary_count > $min_boundary_count )
			{ delete($$href{$_}); }
	}
}

sub format_compound {
	my ($refbase, $refline, $refword) = @_;

	# Take only the analysis of the last part of the compound
	$$refline =~ s/^.*\#(.*?)\s(.*$)/$2/o;
	my $last_word = $1;

	# Search for the 4 first letters of the last base form
	# from the original compound 
	my $substring = substr($last_word,0,4);

	# If the compound boundary was not found,
	# search for the 3 first letters of the last base form
	if ($$refword !~ m/$substring/) {
		my $substring = substr($last_word,0,3);
	}
    # If the compound boundary is not found, 
	# use "last resort": 2 letters instead of 3 or 4.
	if ($$refword !~ m/$substring/) {	
		$substring = substr($last_word,0,2);
	}
    # If the compound boundary is not found, 
	# use "last resort": 1 letters instead of 2 3 or 4.
	if ($$refword !~ m/$substring/) {	
		$substring = substr($last_word,0,1);
	}
	if ($$refword =~ m/$substring/) {
		# If the compound boundary is found, 
		# replace the last word by its base form, and insert a # mark in front of
		# it, in order to mark the result as a compound.
		my $orig = $$refbase;
		$$refbase = $$refword;
		$$refbase =~ s/(^.*)$substring.*$/$1\#$last_word/;
		if ($orig =~ m/^\p{isLower}/) {
			$$refbase = lcfirst($$refbase);
		}
	}
}
