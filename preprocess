#!/usr/bin/perl
use strict;

# preprocess
# Perl-script for text preprocessing 
#  - Cuts text into sentences and sentences into words (tokens).
#  - Reads plain text from STDIN and outputs 
#    a list of words separated by newline.
#
# An abbreviation file may be given as input parameter --abbr, 
# the file has special syntax and the usage is connected 
# to other sámi tools.
# 
# $Id$

# Use the local character class. 
# It means that variable \w contains Latin-1 alphabet.
use locale;

# permit named arguments
use Getopt::Long;

my @words;
my %abbrs;
my $TRAB="TRAB";
my $ITRAB="ITRAB";
my $TRNUMAB="TRNUMAB";
my $IDIOM="IDIOM";

# Max size of a multi-word expression.
my $MULTIWORD_SIZE = 3;

my $PUNCT = quotemeta("|{}[]()$.*?!,;:-'\.\"%");
my $SEPARATE_PUNCT = quotemeta("|{}[]()«»?!;,'\"");

# Regex for tokens that contain punctuation:
my $CONTAIN_PUNCT = 'ja\/dahje|http|:\/\/';

my $abbr_file;
my $help=0;
GetOptions ("abbr=s" => \$abbr_file,
			"help" => \$help) ;

if ($help) {
	&print_usage;
	exit;
}

# If the abbreviation file is given,
# read the abbreviations from the file to a hash.
if ($abbr_file) {
	&read_abbr (\%abbrs);
}

# read one paragraph at the time.
# the paragraph ends with two subsequent newlines.
$/ = "";

while (<>) {
	chomp;

	# join hyphenated words separated by newline
	s/\-\n/\-/g;
	
	# split the sentence by space.
    my @words = split (/[\n\s]+/, $_) ;

	while (@words) {
		my $word = shift (@words) ;
		my @tokens;
		
		# store extra punctuation from the front of the expression
		# to the tokens array.
		if ($word =~ s/^([$SEPARATE_PUNCT]+)//) {
			push (@tokens, split(/ */, $1));
		}
		# Examine the type of the string. If the expression contains
		# alphabetical characters optionally preceded by one non-alphabetic
		# character, it is a word. covers typos as well as hyphen.
		if ($word =~ s/^([\W]?)([^\W\d]+.*)/$2/) {
			if ($1) {
				push (@tokens, $1);
			}
			process_word ($word, \@words, \@tokens);
		}
		# Otherwise it is processed like numeral.
		elsif ($word) {
			process_numeral ($word, \@words, \@tokens);
		}
		for my $token (@tokens) {
			print "$token\n" unless (! $token);
		}
	}
}


sub process_word {
	my ($word, $words_aref, $tokens_aref) = @_;
	
	my $end_punct;
	my $rest_punct;

    # Test for multiword expression.
	test_idiom(\$word, $words_aref, $MULTIWORD_SIZE);

    # Store the punctuation at the end of the string
	if ($word =~ s/([-+=%$SEPARATE_PUNCT]+)$//) {
		$end_punct = $1
	}

	# Cut the word into tokens if there is punctuation in the middle.
	# An Exception!! ja/dahje
	if ($word !~ /$CONTAIN_PUNCT/ && (my @parts = split (/([+=%$SEPARATE_PUNCT\/])/, $word))) {
		my $i;
		for ($i=0; $i < $#parts; $i++) {
			push (@{$tokens_aref}, $parts[$i]); 
		}
		# Process the last part further, it may contain some punctuation
		# that has to be removed.
		$word = $parts[$i];
		if ($word =~ s/^([$PUNCT])//) {
			push (@{$tokens_aref}, $1);
			}
		if (!$word) {
			push (@{$tokens_aref}, split(/ */, $end_punct));
			return;
		}
	}

	# If the punctuation at the end contains a sentence delimiter
	# ? or !, the word ends the sentence in any case.
	if ($end_punct =~ /[\?\!\.]/) {
		push (@{$tokens_aref}, $word);
	}
	# The word is checked for abbreviation and sentence boundary.
	elsif (! test_abbr($word, $words_aref->[0], $tokens_aref)) {
		# If the word was not an abbreviation, the rest
		# of the punctuation is removed and stored as separate tokens.
		if ($word =~ s/([$SEPARATE_PUNCT\.:]+)$//) {
			$rest_punct =  $1;
		}
		push (@{$tokens_aref}, $word);
		push (@{$tokens_aref}, split(/ */, $rest_punct));			
	}
	push (@{$tokens_aref}, split(/ */, $end_punct));
}


sub test_abbr {
	my ($word, $next_word, $tokens_aref) = @_;

	my $abbr = $word;
	if (! ($abbr =~ s/\.$//)) {
		return 0;
	}

	# Transitive abbreviations are never followed
	# by sentence boundary.
	if (exists $abbrs{$TRAB}{$abbr}) {
		push (@{$tokens_aref}, $word);
		return 1;
	}
	# There is a sentence boundary if the abbreviation
	# is followed by other than number or non-alphabetic char.
	elsif (exists $abbrs{$TRNUMAB}{$abbr}) {
		push (@{$tokens_aref}, $word);
		if ($next_word !~ /^[0-9]/ ) {
			push (@{$tokens_aref}, ".");
		}
		return 1;
	}
	# There is a sentence boundary if intransitive abbreviation 
	# is NOT followed by a small alphabetic char.
	elsif (exists $abbrs{$ITRAB}{$abbr}) {
		push (@{$tokens_aref}, $word);
		if ($next_word !~ /^[[:lower:]]/o) {
			push (@{$tokens_aref}, ".");
		}
		return 1;
	}
	# Check for abbreviation with 2-3 capital letters
	# If followed by a capital letter or number,
	# There is a sentence boundary. todo: Remove this as irrelevant!!
	elsif ($abbr =~ /^[[:upper:]1]{2,3}$/o ) {
		if ($next_word !~ /^[[:lower:]]/ ) {
			push (@{$tokens_aref}, $abbr);
			push (@{$tokens_aref}, ".");
		}
		else {
			push (@{$tokens_aref}, $word);
		}
		return 1;
	}
	return 0;
}

# If the word starts an multiword expression, it is replaced
# by the expression. The other parts are
# removed from the words array.

sub test_idiom {
	my ($word_ref, $words_aref, $size) = @_;

	my $token = $$word_ref;
	# Test for multiword expressions by growing the token
	# one word at a time
	my $i=0;
	while ($i < $size && $words_aref->[$i]) {
		$token = $token . " " . $words_aref->[$i];

		# Remove the punctuation at the end of the expression.
		(my $token_2 = $token) =~ s/[^\w]*$//;
		# Test if the formed multiword expression exists in the
		# idiom list. Test also lower case version.		 
		if (exists $abbrs{$IDIOM}{$token_2} || exists $abbrs{$IDIOM}{lcfirst($token_2)} ) {
			for (my $j=0; $j <= $i; $j++) {
				# Construct the new multiword processing unit.
				# Remove the parts of the multiword expression from
				# the word array.
				$$word_ref = $$word_ref . " " . $words_aref->[0];
				shift @{$words_aref};
			}
		}
		$i++;
	}
}


sub process_numeral {
	my ($word, $words_aref, $tokens_aref) = @_;
	
	# Combine hyphen with numeral if followed by other numeral.
	# cases 123- 456 and 123 -456 and 123 456 and 123 - 456
	while (($word =~ /[\d-]$/) && ($words_aref->[0] =~ /^-$|^-?\d+/)) {
		$word = $word . " " . $words_aref->[0];
		shift @{$words_aref};
	}

	# Combine percent sign to the numeral when separate.
	# covers cases like: 50 %
	if (($word =~ /\d$/) && ($words_aref->[0] =~ /^\%/)) {
		$word = $word . " " . $words_aref->[0];
		shift @{$words_aref};
	}
	# Clean first the end of the token:
	# cases like: 123! and 123.) problem: 123.? and 123 is an ordinal.
	my $end_punct;
	if ($word =~ s/([$SEPARATE_PUNCT:]+)$//){
		$end_punct = $1;
	}
	my $rest_punct;
	# Ending dot is a separate token if 
	# the following word starts with capital letter.
	# Otherwise belongs to the expression.
	if (($words_aref->[0] !~ /^[[:lower:]\d]/o) && ($word =~ s/(\.)$// )) {
		$end_punct = $1 . $end_punct;
		
		# Clean the rest of the token:
		# cases like 123).
		if ($word =~ s/([$SEPARATE_PUNCT:]+)$//) {
			$rest_punct =  $1;
		}
	}
	# Push everything to the tokens array.
	push (@{$tokens_aref}, $word);
	push (@{$tokens_aref}, split(/ */, $rest_punct));
	push (@{$tokens_aref}, split(/ */, $end_punct));
}


sub read_abbr {
	my ($abbr_href) = @_;
	
	local $/="\n";
    # The filename may contain a tilde ~
    # Expand the filename manually
	$abbr_file =~ s{^~([^/])*} {
		$1
			? (getpwnam($1))[7]
			: ($ENV{HOME} || (getpwuid($>))[7]
			   )
		}ex;

	open LEX, "< $abbr_file" or die "Cant open the file: $!\n";

	my $current;
	while (<LEX>) {
		chomp;
		if (/^LEXICON (.*)$/) {
			$current = $1;
			next;
		}
		$$abbr_href{$current}{$_} = 1;
	}
	close LEX;	
}

sub print_usage {
	print "Usage: preprocess --abbr=<file_name>\n";
	print "Split text into sentences and words.\n"
}




