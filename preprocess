#!/usr/bin/perl
use strict;
use open ':locale';

# preprocess
# Perl-script for text preprocessing 
#  - Cuts text into sentences and sentences into words (tokens).
#  - Reads plain text from STDIN and outputs 
#    a list of words separated by newline.
#
# An abbreviation file may be given as input parameter --abbr, 
# the file has special syntax and the usage is connected 
# to other sámi tools.
# 
# $Id$

# Use the local character class. 
# It means that variable \w contains Latin-1 alphabet.
#use locale;

# permit named arguments
use Getopt::Long;

my @words;
my %abbrs;
my %corrections;
my $TRAB="TRAB";
my $ITRAB="ITRAB";
my $TRNUMAB="TRNUMAB";
my $IDIOM="IDIOM";

# Max size of a multi-word expression.
my $MULTIWORD_SIZE = 3;

#  «»‹›“”„‘’‚ ´`'"
my $quotations = "\x{00AB}\x{00BB}\x{2039}\x{203A}\x{201C}\x{201D}\x{201E}\x{2018}\x{2019}\x{201A}\x{00B4}\x{0060}\'\"";
#… and • ¶ en-dash em-dash
my $other = "\x{2026}\x{2022}\x{00B6}\x{2013}\x{2014}";
my $parentheses = quotemeta("|{}[]()<>");
my $general_punct = quotemeta("$.*?!,;:.%");

# áčđŋšŧžåæøäöå n_with_tilde
my $lc_class = "\x{00E1}\x{010D}\x{0111}\x{014B}\x{0161}\x{0167}\x{017E}\x{00E6}\x{00F8}\x{00E4}\x{00F6}\x{00E5}\x{00F1}";
# ÁČĐŊŠŦŽÅÆØÄÖÅ N_with_tilde
my $uc_class = "\x{00C1}\x{010C}\x{0110}\x{014A}\x{0160}\x{0166}\x{017D}\x{00E5}\x{00D8}\x{00C4}\x{00D6}\x{00C5}\x{00D1}";

# General punctuation, not much used. 
my $PUNCT = $quotations . $parentheses . $general_punct . $other;

# Punctuation marks that are always their own tokens,
# whether word or numeral expression.
# There are characters added to this list depending on if
# the processed string is word or numeral.
my $SINGLE_PUNCT = $quotations . $parentheses . quotemeta("?!,;/\\") . $other;

# Regex for tokens that nevertheless contain punctuation that
# is specified in variable $SINGLE_PUNCT.
my $CONTAIN_PUNCT = 'ja\/dahje|http|:\/\/|km\/h|www|@|\.jpg|\.doc|\.pdf|\.html|\.txt';

# Punctuation that connects two or more numerals 
# into one numeral expressions.
my $NUM_PUNCT=quotemeta("-+*=/");

my $abbr_file;
my $help=0;
my $verbose=0;
my $hyph=0;
my $use_hyph_tag=0;
my $fst;
my $corr;

GetOptions ("abbr=s" => \$abbr_file,
			"fst=s" => \$fst,
			"corr=s" => \$corr,
			"help" => \$help,
			"v" => \$verbose,

			"hyph" => \$hyph,
			"use-hyph-tag" => \$use_hyph_tag) ;

if ($help) {
	&print_usage;
	exit;}

my %idioms;
my %idioms_short;
# If the abbreviation file is given,
# read the abbreviations from the file to a hash.
if ($abbr_file) {
	&read_abbr (\%abbrs, \%idioms, \%idioms_short);
}
# Read the corrections file (typos.txt)
if ($corr) {
	&read_corr (\%corrections);
}

sub verbose {
	my ($from, $word, $linenumber) = @_;
	
	if (!$verbose) {
		return;
	}
	
	print STDERR "[$from:$linenumber] $word\n";
}

# Read one line at a time but keep track on the next line.

my $next_line=undef;
my $cur_line=undef;
my @next_words;
my @words;

while (<>) {
	chomp;

	next if (/^\s*$/);
	
	# Process the <hyph> tag.
	if (! $use_hyph_tag) {
		if ($hyph) { s/\<hyph\>/-/g; }
		else { s/\<hyph\>//g; }
	}

	# Process always the previous line, unless first line.
	if(!@words) { 
		@words = split(/\s+/);
		if (!eof) { next; }
		else { @next_words=undef; pop @next_words; }
	}
	else { @next_words = split; }

	process_words();
}

process_words();

sub process_words {
	
	while (@words) {
		
		my $word = shift @words;
		
		# An array for storing the tokens, each token in its own slot.
		my @tokens;
		
		# Move forward if the word is nothing special. 
        # This is for making preprocessing faster.
		if ($word =~ /^[^\W\d\s\n]*$/) {
			if($corr && $corrections{$word}) { $word = $corrections{$word}; }
			if (! $idioms_short{$word}) {
				print "$word\n";
				next;
			}
		}
		PROCESS_WORD: {
			# Fix some punctuation, like ...voxende
			if ($word =~ /^(.*?)(:?\.){3,}(.*)$/) {
				my $first_word = $1;
				my $second_word = $3;
				if ($first_word) {
					if ($first_word =~ /^[\W]?[^\W\d]+/) { 
						verbose("if word with dots", $first_word , __LINE__);
						process_word ($first_word, \@words, \@tokens);
					} else {
						verbose("if numeral with dots", $first_word , __LINE__);
						process_numeral ($first_word, \@words, \@tokens);
					}
				}
				push (@tokens, "...");
				if ($second_word) {
					if ($second_word =~ /^[\W]?[^\W\d]+/) { 
						verbose("if word with dots", $second_word , __LINE__);
						process_word ($second_word, \@words, \@tokens);
					} else {
						verbose("if numeral with dots", $second_word , __LINE__);
					process_numeral ($second_word, \@words, \@tokens);
					}
				}
				last PROCESS_WORD;
			}

			# store punctuation from the front of the expression
			# to the tokens array. (todo: check variable $CONTAIN_PUNCT)
			if ($word =~ s/^([$SINGLE_PUNCT]+)//o) {
				verbose("if front punct ", $word , __LINE__);
				push (@tokens, split(//, $1));
			}
			# Examine the type of the string. If the expression contains
			# alphabetical characters optionally preceded by one non-alphabetic
			# character, it is a word.
			if ($word =~ /^[\W]?[^\W\d]+/) {
				verbose("if word", $word , __LINE__);
				process_word ($word, \@words, \@tokens);
			}
			# Otherwise it is processed like numeral.
			else {
				process_numeral ($word, \@words, \@tokens);
			}
		} # end of PROCESS_WORD

		for my $token (@tokens) {
			print "$token\n" unless ($token =~ /^$/);
		}
	}
	@words=@next_words;
}


sub process_word {
	my ($word, $words_aref, $tokens_aref) = @_;

	# variable for storing all the punctuation at the end of the word.
	# except dot (for abbreviations) and some other punct. if needed
	my $end_punct;
	# the variable storing dot and the possible some other punct.
	my $rest_punct;

    # Test for multiword expression.
	if ($corr ) { if ($corrections{$word}) { $word = $corrections{$word}; } }
	test_idiom(\$word, $words_aref, $MULTIWORD_SIZE);

    my $end_num;
    if ($word =~ /\.(\d+\.?)$/){
        $word =~ s/(\d+\.?)$//;
        $end_num = $1;
        verbose ("process_word/end_num", $end_num, __LINE__);
    }

    # Store the punctuation at the front of the string to tokens array.
	if ($word =~ s/^([+=%:-]+)$//o) {
		push (@{$tokens_aref}, split(//, $1));
		verbose ("process_word/front_punct", $1, __LINE__);
	}

    # Store the punctuation at the end of the string to a variable
	if ($word =~ s/([+=%:$SINGLE_PUNCT]+)$//o) {
		$end_punct = $1;
		verbose ("process_word/end_punct", $end_punct, __LINE__);
	}

	# Cut the word into tokens if there is punctuation in the middle.
	# e.g. gielddat/guovllut
	# Check for expressions in $CONTAIN_PUNCT -variable.
	if ($word !~ /$CONTAIN_PUNCT/o && (my @parts = split (/([+=%$SINGLE_PUNCT\/])/o, $word))) {
		$word = pop @parts;
		if ($corr ) { if ($corrections{$word}) { $word = $corrections{$word}; } }
		push (@{$tokens_aref}, @parts);
		verbose ("process_word/contain_punct", "$word", __LINE__);

		# Process the last part further, it may start with punctuation
		# that is separate token.
		if ($word =~ s/^([-$PUNCT])//o) {
			push (@{$tokens_aref}, $1);
			verbose ("process_word/contain_punct/last_part", "$1", __LINE__);
			}
		if (!$word) {
			push (@{$tokens_aref}, split(//, $end_punct));
			return 1;
		}
	}

  TEST: {
	  # If the punctuation at the end contains a sentence delimiter
	  # ? or !, the word ends the sentence in any case, so the word can
	  # be treated as a token.
	  if ($end_punct =~ /[¶\?\!\.]/) {
		  if($corr) { if ($corrections{$word}) { $word = $corrections{$word}; } }
		  push (@{$tokens_aref}, $word);
		  last TEST;
	  }

	  # The word is checked for abbreviation and sentence boundary.
	  my $abbr = $word;
	  if ($abbr =~ s/\.$//) {
		  if ($abbrs{$abbr}) {
			  test_abbr($word, $words_aref->[0], $tokens_aref);
			  last TEST;
		  }	  
		  # Check for abbreviation with 2-3 capital letters
		  # If followed by a capital letter or number,
		  # There is a sentence boundary. todo: Remove this as irrelevant!!
		  elsif ($abbr =~ /^[A-Z$uc_class]{2,3}$/o ) {
			  if ($words_aref->[0] !~ /^[a-z$lc_class]/o ) {
				  if($corr) { if ($corrections{$word}) { $word = $corrections{$word}; } }
				  push (@{$tokens_aref}, $abbr);
				  push (@{$tokens_aref}, ".");
				  last TEST;
			  }
			  else {
				  push (@{$tokens_aref}, $word); 
				  last TEST;
			  }
		  }
	  }
	  # If the word was not an abbreviation, the rest
	  # of the punctuation is removed and stored as separate tokens.
	  # This operation is for taking the dot out.
	  if ($word =~ s/([$SINGLE_PUNCT\.:]+)$//o) {
		  $rest_punct =  $1;
		  verbose ("process_word/rest_punct", $rest_punct, __LINE__);
		  if($corr) { if ($corrections{$word}) { $word = $corrections{$word}; } }
		  push (@{$tokens_aref}, $word);
		  push (@{$tokens_aref}, $rest_punct);
		  last TEST;
	  }
	  push (@{$tokens_aref}, $word); 

  } # end of block TEST

	push (@{$tokens_aref}, $end_num); 
	push (@{$tokens_aref}, split(//, $end_punct));
}


sub test_abbr {
	my ($word, $next_word, $tokens_aref) = @_;

	my $abbr = $word;
	if (! ($abbr =~ s/\.$//)) {
		return 0;
	}

	# Transitive abbreviations are never followed
	# by sentence boundary.
	if ($abbrs{$abbr} eq $TRAB) {

		push (@{$tokens_aref}, $word);
		return 1;
	}
	# There is CLB after TRNUMAB only for the capital+small combinations
	# and all small-initial strings that consist of more than one letter.
	# For all other strings (one small letter, one or several capital letters) we
	# want no CLB after TRNUMAB.
	elsif ($abbrs{$abbr} eq $TRNUMAB) {
		push (@{$tokens_aref}, $word);
		if ($next_word =~ /^[A-Z$uc_class]?[a-z$lc_class]{2,}/o) {
			push (@{$tokens_aref}, ".");
		}
		return 1;
	}
	# There is a sentence boundary if intransitive abbreviation 
	# is NOT followed by a small alphabetic char.
	elsif ($abbrs{$abbr} eq $ITRAB) {
		push (@{$tokens_aref}, $word);
		if ($next_word !~ /^[a-z$lc_class$PUNCT]/o) {
			push (@{$tokens_aref}, ".");
		}
		return 1;
	}

	return 0;
}

# If the word starts an multiword expression, it is replaced
# with the expression. The other parts are
# removed from the words array.

sub test_idiom {
	my ($word_ref, $words_aref, $size) = @_;

	# Test for multiword expressions by growing the token
	# one word at a time
	my $next=0;
	my $i=0;
	my $last_part;
	if( $words_aref->[0] ) { $last_part = $words_aref->[0]; }
	elsif ($next_words[0]) { $last_part = $next_words[0]; $next=1; }
	else { return 0; }
	while ($i <= $size) {

		# Remove the punctuation at the end of the expression.
		(my $last_part_2 = $last_part) =~ s/[^\w]*$//;

		# If the expressions contains punctuation in the middle, return.
		return if ($last_part_2 =~ /[^\w\s\d]/);

		# Test if the formed multiword expression exists in the
		# idiom list. Test also lower case version.
		my $idiom = $$word_ref . " " . $last_part_2;

		my $ucidiom = ucfirst($$word_ref) . " " . ucfirst($last_part_2);
		if ($idioms{$idiom} || $idioms{lc($idiom)} || $idioms{($ucidiom)}) {
			for (my $j=0; $j <= $i; $j++) {
				# Construct the new multiword processing unit.
				# Remove the parts of the multiword expression from
				# the word array.
				if($next) { 
					$$word_ref = $$word_ref . " " . $next_words[0];
					shift @next_words;
				}
				else {
					$$word_ref = $$word_ref . " " . $words_aref->[0]; 
					shift @{$words_aref}; 
				}
			}
			return 1;
		}
		$i++;
		if($words_aref->[$i]) { 
			$last_part = $last_part . " " . $words_aref->[$i];
			$last_part =~ s/\s+/ /g;
		}
		elsif(! $next && $next_words[0]) { 
			$last_part = $last_part . " " . $words_aref->[0];
			$next=1;
		}
		else { return 0; }
	}
}

sub process_numeral {
	my ($word, $words_aref, $tokens_aref) = @_;

	# Combine punctuation with numeral if followed by other numeral.
	# cases like 123- 456 and 123 -456 and 123 456 and 123 - 456
	while (($word =~ /^[\d$NUM_PUNCT ]+$/o) && ($words_aref->[0] =~ /^[\d$NUM_PUNCT ]+$/o)) {
		$word = $word . " " . $words_aref->[0];
		shift @{$words_aref};
	}

	# Combine percent sign to the numeral when separate.
	# covers cases like: 50 %
	if (($word =~ /\d$/) && ($words_aref->[0] =~ /^\%/)) {
		$word = $word . " " . $words_aref->[0];
		shift @{$words_aref};
	}
	
	verbose ("process_numeral", $word, __LINE__);
	
	# Clean first the end of the token, where punctuation follows
	# the numeral or an ordinal and does not belong to the expression.
	# cases like: 123! and 123.), 123). 10,-. 
    # problem: 123.? and 123 is an ordinal.
	my $end_punct;
	if ($word =~ s/([$SINGLE_PUNCT:]+\.?)$//o){
		$end_punct = $1;
	}
	if ($word =~ /([$SINGLE_PUNCT:\-\%]+\.?)$/o){
		$word =~ s/(\.?)$//;
		$end_punct = $1;
	}
	
	verbose ("process_numeral", $word, __LINE__);

	# Check if there is an abbreviation or a word attached to
	# numeral. E.g. 6.b. ...ovdal. This introduces problems with some
	# mispellings with headings, like 1.6.Vuonain 
	my $end_word;
	if ($word =~ /\.([^\W\d]+\.?)$/ && $word !~ /$CONTAIN_PUNCT/o) { 
		$word =~ s/([^\W\d]+\.?)$//;
		push (@$tokens_aref, $word);
		$end_word = $1;
	}

	
	verbose ("process_numeral/end_word", $end_word, __LINE__);
	verbose ("process_numeral/abbr", $word, __LINE__);

	my $rest_punct;

	NUM_TEST: {
		
		# Check for ending dot, it is a separate token if 
		# the following word starts with capital letter.
		# If there is an abbreviation with numeral, don't do checking.
		# Otherwise belongs to the expression.
		if ($end_word) {
			my $abbr = $end_word;
			if (( $abbr =~ s/\.$//)  && $abbrs{$abbr}) {
				test_abbr($end_word, $words_aref->[0], $tokens_aref);
				last NUM_TEST;
			}
			else { 
				process_word ($end_word, $words_aref, $tokens_aref);
				last NUM_TEST;
			}
		}
		
	  DOT_TEST: {
		  last DOT_TEST if ($word !~ /\.$/);
		  if((($words_aref->[0] !~ /^[a-z$lc_class\d]/o) && $word !~ /^\d{1,3}\.$/) || ($word =~ /(:\w+)(\.)$/)) {
			  $word =~ s/\.$//;
		  }
		  elsif ($word =~ /^\d{1,3}\.$/) {
			  if ($words_aref->[0] !~ /^[A-Z$uc_class]/o) {
				  last DOT_TEST;
			  }
		  }
		  else { last DOT_TEST; }
		  $end_punct = "." . $end_punct;
		  
		  verbose ("process_numeral/ending dot", $word, __LINE__);
		  
		  # Clean the rest of the token:
		  # cases like 123). where dot is preceded by punctuation.
		  if ($word =~ s/([$SINGLE_PUNCT:]+)$//o) {
			  $rest_punct =  $1;
		  }
	  } # end of DOT_TEST

		verbose ("process_numeral", $word, __LINE__);
		
		# Push everything to the tokens array.
		push (@{$tokens_aref}, $word);
		push (@{$tokens_aref}, $end_word);
		
	} #end of NUM_TEST
	
	push (@{$tokens_aref}, split(//, $rest_punct)); 
	push (@{$tokens_aref}, split(//, $end_punct)); 
}

sub read_corr {
	my ($corr_href) = @_;

	local $/="\n";

	open CORR, "< $corr" or die "Cant open the file: $!\n";

	while (<CORR>) {
		chomp;
		
		next if (/^!/);
		next if (/^\s*$/);
		next if (/^\#/);
		
		my ($error, $correct) = split(/\t+/);
		if ($error && $correct) { $$corr_href{$error} = $correct; }
		else { print STDERR "preprocess warning: Line not included to typos: $_\n"; }
	}
}


sub read_abbr {
	my ($abbr_href, $idiom_href, $idiom_short_href) = @_;
	
	local $/="\n";
    # The filename may contain a tilde ~
    # Expand the filename manually
	$abbr_file =~ s{^~([^/])*} {
		$1
			? (getpwnam($1))[7]
			: ($ENV{HOME} || (getpwuid($>))[7]
			   )
		}ex;

	open LEX, "< $abbr_file" or die "Cant open the file: $!\n";

	my $current;
	while (<LEX>) {
		chomp;		
		last if (/^LEXICON IDIOM/);
		if (/^LEXICON\s+(.*?)\s*$/) {
			$current = $1;
			next;
		}
		$$abbr_href{$_} = $current;
	}
	while (<LEX>) {
		chomp;
		last if (/^LEXICON IDIOM/);
		my ($first, $last) = split(/ /, $_, 2);
		$$idiom_href{$_} = 1;
		$$idiom_short_href{$first} = 1;
	}
	close LEX;	

#	for my $key (keys %$idiom_href) {
#		print "$key $$idiom_href{$key}\n";
#	}
}

sub print_usage {
	print "Usage: preprocess [OPTIONS] --abbr=<file_name> FILES\n";
	print "Split text in FILE into sentences and words.\n";
	print "Options\n";
	print "--hyph          show the hyphenation points, i.e. change the <hyph> tags\n";
    print "                to hyphens. The default is to just remove the <hyph> tags.\n";
    print "--use-hyph-tags leave the <hyph> tags untouched\n";
    print "--help          prints the help text and exit.\n";
    print " --v            prints information of the execution of the script\n";
	print " --corr=<file>  list of common typos and their corrections (e.g. typos.txt)\n";

}



